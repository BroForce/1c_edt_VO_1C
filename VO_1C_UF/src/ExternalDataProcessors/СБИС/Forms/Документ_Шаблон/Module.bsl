&НаКлиенте
Перем МестныйКэш Экспорт;
&НаКлиенте
Функция сбисПолучитьФорму(ИмяФормы)
	Если ТипЗнч(ЭтаФорма) = Тип("УправляемаяФорма") Тогда
		Попытка
			ЭтотОбъект="";
		Исключение
		КонецПопытки;
		Возврат ПолучитьФорму("ВнешняяОбработка.СБИС.Форма."+ИмяФормы);
	КонецЕсли;
	Возврат ЭтотОбъект.ПолучитьФорму(ИмяФормы);
КонецФункции
&НаКлиенте
Процедура сбисПоказатьСостояние(ТекстСостояния, Форма = Неопределено, Индикатор = Неопределено, Пояснение = "")
	Если ТипЗнч(ЭтаФорма) = Тип("УправляемаяФорма") Тогда
		Состояние(ТекстСостояния,Индикатор,Пояснение);
	Иначе
		Форма.ЭлементыФормы.ПанельОжидания.Видимость = Истина;
		Форма.НадписьОжидания = Символы.ПС + ТекстСостояния;
		Форма.НадписьПояснение = Пояснение;
		Если Индикатор<>Неопределено Тогда
			Форма.ЭлементыФормы.Индикатор.Видимость = Истина;
			Форма.ЭлементыФормы.Индикатор.Значение = Индикатор;
		КонецЕсли;
	КонецЕсли;	
КонецПроцедуры
&НаКлиенте
Процедура сбисСпрятатьСостояние(Форма = Неопределено)
	Если ТипЗнч(ЭтаФорма) = Тип("УправляемаяФорма") Тогда
	Иначе
		Форма.ЭлементыФормы.ПанельОжидания.Видимость = Ложь;
		Форма.ЭлементыФормы.Индикатор.Видимость = Ложь;
	КонецЕсли;	
КонецПроцедуры
//------------------------------------------------------

// Отправка документов
&НаКлиенте
Процедура ОтправитьДокументы(Кэш,МассивСтрок) Экспорт
	// Процедура формирует и отправляет пакеты документов по отмеченным строкам в реестре	
	ГлавноеОкно = Кэш.ГлавноеОкно;
	УжеАктивированы = Новый СписокЗначений;
	ИННОтправителей = Новый СписокЗначений;
	МассивПакетов = Новый Массив;  // Массив пакетов для одной отправки (если в настройках указано отправлять пакеты по n штук)
	Кэш.СписокНоменклатуры.Очистить();
	ВремяНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
	РезультатОтправки = Новый Структура("ТипыОшибок,Отправлено,НеОтправлено,НеСформировано,Ошибок,ДетализацияОшибок,ВсегоПакетов,ОшибкиДоОтправки,ДанныеПоСтатусам,ПорНомер,КоличествоСвободныхПотоков,ОтправленоСообщений,ПолученоОтветов,ВремяНачала,ВремяФормирования,ВремяОтправки,ДетализацияОтправки,ВремяЗаписиСтатусов,ВремяПолученияДанных,ВремяОжиданияОтвета, СформированныеПакеты", Новый СписокЗначений,0,0,0,0, Новый Соответствие,0,0,Новый Массив,0,Кэш.КоличествоПотоковОтправки,0,0,ВремяНачала,0,0, Новый Соответствие,0,0,0, Новый Соответствие);
	РезультатОтправки.Вставить("НаЗаписьСтатусов", Новый Структура("Ошибки, Ответы", Новый Соответствие, Новый Соответствие));
	Кэш.Вставить("РезультатОтправки",РезультатОтправки);

	//Кэш.Интеграция.ЗакрытьСессию(Кэш);
	
	РезультатОтправки = ОтправитьДокументыПоМассивуСтрок(Кэш,МассивСтрок,0,МассивПакетов,ИННОтправителей, УжеАктивированы);
	Если ТипЗнч(РезультатОтправки) = Тип("Структура") Тогда  // если необходимо активировать сертификаты перед отправкой
		СчетчикВведенныхПинкодов = 0;
		счСертификатов = 0;
		Для Каждого Элемент Из РезультатОтправки.СписокСертификатов Цикл
			Сертификат = Элемент.Значение;
			Если Сертификат.Ключ.СпособАктивации<>"СтатическийКод" Тогда
				Кэш.Интеграция.ПолучитьКодАктивацииСертификата(Кэш, Сертификат);				
			КонецЕсли;
			СертификатИмя = "Введите код активации сертификата "+Кэш.ОбщиеФункции.СокращенноеФИО(Кэш,Сертификат.ФИО)+?(Сертификат.Свойство("Должность"),"("+Сертификат.Должность+")", "")+", "+Сертификат.Название+?(Сертификат.Свойство("ИНН"),"(ИНН "+Сертификат.ИНН+")","");
			ОткрытьФорму("ВнешняяОбработка.СБИС.Форма.ФормаВводаПинкода",Новый Структура("СертификатИмя,счСертификатов",СертификатИмя,счСертификатов),ЭтаФорма,счСертификатов,,,Новый ОписаниеОповещения("АктивироватьСертификатыЗавершение",ЭтаФорма,Новый Структура("Кэш,РезультатОтправки",Кэш,РезультатОтправки)));	
			счСертификатов = счСертификатов+1;
		КонецЦикла;
	КонецЕсли;
	сбисСпрятатьСостояние(ГлавноеОкно);
КонецПроцедуры
&НаКлиенте
Функция ОтправитьДокументыПоМассивуСтрок(Кэш,МассивСтрок,счСтрок,МассивПакетов,ИННОтправителей, УжеАктивированы) Экспорт
	// Функция формирует и отправляет пакеты документов по отмеченным строкам в реестре, начиная с счСтрок	
	ГлавноеОкно = Кэш.ГлавноеОкно;
	
	//ПолныйМассивПакетов = Новый Массив;  // Полный массив пакетов для отправки
	Всего = МассивСтрок.Количество();
	ПоследняяПартия = Ложь;
	
	ПодключитьОбработчикОжидания("ПрерываниеПользователемФормированияДокументов",0.1,Истина);
	Пока счСтрок<Всего Цикл //Отправляемые пакеты
		Строка = МассивСтрок[счСтрок];
		Если Кэш.Свойство("ПрерватьОтправку") и Кэш.ПрерватьОтправку = Истина Тогда
			Прервать;
		КонецЕсли;
		счСтрок = счСтрок+1;
		Если счСтрок = Всего Тогда
			ПоследняяПартия = Истина;
		КонецЕсли;
		сбисПоказатьСостояние("Формирование электронных документов",ГлавноеОкно,Мин(100,Окр(счСтрок*100/Всего)), "(прервать -  Ctrl+Break)");
		ДатаНач = ТекущаяУниверсальнаяДатаВМиллисекундах();
		МассивПодготовленныхПакетов = Кэш.Текущий.Форма.ПодготовитьСтруктуруДокумента(Строка.Значение, Кэш, ЛОЖЬ);
		ДатаКнц = ТекущаяУниверсальнаяДатаВМиллисекундах();
		Кэш.РезультатОтправки.ВремяФормирования = Кэш.РезультатОтправки.ВремяФормирования+(ДатаКнц-ДатаНач)/1000;
		РезультатОтправки = ОтправитьПодготовленныеДокументы(Кэш, МассивПодготовленныхПакетов,0,МассивСтрок,счСтрок, МассивПакетов, ИННОтправителей, УжеАктивированы, ПоследняяПартия);
		Если РезультатОтправки = Ложь Тогда
			сбисСпрятатьСостояние(ГлавноеОкно);
			Возврат Ложь;
		КонецЕсли;
		Если ТипЗнч(РезультатОтправки) = Тип("Структура") Тогда
			Возврат РезультатОтправки;
		КонецЕсли;
		
		ОбработкаПрерыванияПользователя();
	КонецЦикла;
	ОтключитьОбработчикОжидания("ПрерываниеПользователемФормированияДокументов");
	сбисСпрятатьСостояние(ГлавноеОкно);
КонецФункции
&НаКлиенте
Функция ОтправитьПодготовленныеПакетыДокументы(Кэш, МассивПодготовленныхПакетов) Экспорт
	// Функция отправляет подготовленные пакеты документов. Вызывается из форм просмотра, пересылки и отправки корреспонденции
	УжеАктивированы = Новый СписокЗначений;
	ИННОтправителей = Новый СписокЗначений;
	МассивПакетов = Новый Массив;
	ПоследняяПартия = Истина;
	РезультатОтправки = ОтправитьПодготовленныеДокументы(Кэш, МассивПодготовленныхПакетов,0,Новый Массив,0, МассивПакетов, ИННОтправителей, УжеАктивированы, ПоследняяПартия);
	Если ТипЗнч(РезультатОтправки) = Тип("Структура") Тогда  // если необходимо активировать сертификаты перед отправкой
		СчетчикВведенныхПинкодов = 0;
		счСертификатов = 0;
		Для Каждого Элемент Из РезультатОтправки.СписокСертификатов Цикл
			Сертификат = Элемент.Значение;
			Если Сертификат.Ключ.СпособАктивации<>"СтатическийКод" Тогда
				Кэш.Интеграция.ПолучитьКодАктивацииСертификата(Кэш, Сертификат);				
			КонецЕсли;
			СертификатИмя = "Введите код активации сертификата "+Кэш.ОбщиеФункции.СокращенноеФИО(Кэш,Сертификат.ФИО)+?(Сертификат.Свойство("Должность"),"("+Сертификат.Должность+")", "")+", "+Сертификат.Название+?(Сертификат.Свойство("ИНН"),"(ИНН "+Сертификат.ИНН+")","");
			ОткрытьФорму("ВнешняяОбработка.СБИС.Форма.ФормаВводаПинкода",Новый Структура("СертификатИмя,счСертификатов",СертификатИмя,счСертификатов),ЭтаФорма,,,,Новый ОписаниеОповещения("АктивироватьСертификатыЗавершение",ЭтаФорма,Новый Структура("Кэш,РезультатОтправки",Кэш,РезультатОтправки)));	
			счСертификатов = счСертификатов+1;
		КонецЦикла;
	КонецЕсли;	
КонецФункции
&НаКлиенте
Функция ОтправитьПодготовленныеДокументы(Кэш, МассивПодготовленныхПакетов,счПодготовленныхПакетов,МассивСтрок,счСтрок, МассивПакетов, ИННОтправителей, УжеАктивированы, ПоследняяПартия) Экспорт
	// Функция отправляет подготовленный пакеты. 	
	Если Кэш.РезультатОтправки.Свойство("ПрерватьОтправку") и Кэш.РезультатОтправки.ПрерватьОтправку<>Истина Тогда    // при отправке были проблемы со связью
		Сообщить("Отправка была прервана."+Символы.ПС + Кэш.РезультатОтправки.ПрерватьОтправку );
		Кэш.ФормаОтправки.сбисПолучитьОтветыПоОтправке(Кэш);
		Кэш.ГлавноеОкно.ОбновитьКонтент();
		
		Возврат Ложь;
	КонецЕсли;
	
	КолПакетов = МассивПодготовленныхПакетов.Количество();
	Пока счПодготовленныхПакетов<КолПакетов Цикл
		Пакет = МассивПодготовленныхПакетов[счПодготовленныхПакетов];
					
		счПодготовленныхПакетов = счПодготовленныхПакетов+1;
		ПолныйСоставПакета = Пакет;
		
		//++ Бухов А. Точка входа при отправке пакетов документов
		фрм = Кэш.ГлавноеОкно.сбисНайтиФормуФункции("сбисПослеФормированияПакетаДокументов","Документ_"+Кэш.Текущий.ТипДок,"Документ_Шаблон", Кэш);
		Если фрм<>Ложь Тогда
			ПолныйСоставПакета = фрм.сбисПослеФормированияПакетаДокументов(ПолныйСоставПакета, Кэш);	
		КонецЕсли;
		//-- Бухов А. Точка входа при отправке пакетов документов
		
		Если ПолныйСоставПакета.Свойство("Ошибка") Тогда
			Кэш.РезультатОтправки.ОшибкиДоОтправки = Кэш.РезультатОтправки.ОшибкиДоОтправки + 1;
			Если ПолныйСоставПакета.Свойство("Вложение") и ПолныйСоставПакета.Вложение.Количество()>0 и ПолныйСоставПакета.Вложение[0].Свойство("Документы1С") Тогда
				ОсновнойДокумент1С = ПолныйСоставПакета.Вложение[0].Документы1С[0].Значение;
			Иначе
				ОсновнойДокумент1С = Неопределено;
			КонецЕсли;
			Кэш.ОбщиеФункции.ДобавитьОшибкуВРезультатОтправки(Кэш, ПолныйСоставПакета.Ошибка, ПолныйСоставПакета.Ошибка, ОсновнойДокумент1С);
		Иначе
			ИННОтправителя = ?(ПолныйСоставПакета.НашаОрганизация.Свойство("СвФЛ"),ПолныйСоставПакета.НашаОрганизация.СвФЛ.ИНН,ПолныйСоставПакета.НашаОрганизация.СвЮЛ.ИНН);
			Если ИННОтправителей.НайтиПоЗначению(ИННОтправителя)=Неопределено и УжеАктивированы.НайтиПоЗначению(ИННОтправителя)=Неопределено Тогда 
				ИННОтправителей.Добавить(ИННОтправителя);
			КонецЕсли;
			Если ПолныйСоставПакета.Свойство("Вложение") Тогда
				МассивПакетов.Добавить(ПолныйСоставПакета);
				Если МассивПакетов.Количество() = Кэш.КоличествоВОтправке Тогда
					// если надо активировать сертификаты
					Если ИННОтправителей.Количество()>0 Тогда
						СписокСертификатов = Кэш.Интеграция.ПолучитьСертификатыДляАктивации(Кэш, ИННОтправителей);
						Если СписокСертификатов.Количество()>0 Тогда
							Возврат Новый Структура("МассивПакетов, СписокСертификатов, МассивПодготовленныхПакетов, счПодготовленныхПакетов,МассивСтрок,счСтрок, ИННОтправителей, УжеАктивированы, ПоследняяПартия", МассивПакетов, СписокСертификатов, МассивПодготовленныхПакетов, счПодготовленныхПакетов,МассивСтрок,счСтрок, ИННОтправителей, УжеАктивированы, ПоследняяПартия);
						КонецЕсли;
						Для Каждого Элемент Из ИННОтправителей Цикл
							УжеАктивированы.Добавить(Элемент.Значение);
						КонецЦикла;
						ИННОтправителей.Очистить();
					КонецЕсли;
					// если ничего не надо активировать, то отправляем партию пакетов
					ОтправитьПартиюПакетов(Кэш, МассивПакетов);
				КонецЕсли;
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если ПоследняяПартия Тогда
		
		Если ИННОтправителей.Количество()>0 Тогда
			СписокСертификатов = Кэш.Интеграция.ПолучитьСертификатыДляАктивации(Кэш, ИННОтправителей);
			Если СписокСертификатов.Количество()>0 Тогда
				Возврат Новый Структура("МассивПакетов, СписокСертификатов, МассивПодготовленныхПакетов, счПодготовленныхПакетов,МассивСтрок,счСтрок, ИННОтправителей, УжеАктивированы, ПоследняяПартия", МассивПакетов, СписокСертификатов, МассивПодготовленныхПакетов, счПодготовленныхПакетов,МассивСтрок,счСтрок, ИННОтправителей, УжеАктивированы, ПоследняяПартия);
			КонецЕсли;
			Для Каждого Элемент Из ИННОтправителей Цикл
				УжеАктивированы.Добавить(Элемент.Значение);
			КонецЦикла;
			ИННОтправителей.Очистить();
		КонецЕсли;
		
		ОтправитьПартиюПакетов(Кэш, МассивПакетов);
		
		Кэш.ФормаОтправки.сбисПолучитьОтветыПоОтправке(Кэш);
		Кэш.РезультатОтправки.НеОтправлено = Кэш.РезультатОтправки.ВсегоПакетов-Кэш.РезультатОтправки.Отправлено+Кэш.РезультатОтправки.ОшибкиДоОтправки;
		фрм = Кэш.ГлавноеОкно.сбисНайтиФормуФункции("сбисПослеОтправкиПакетов","РаботаСДокументами1С","", Кэш);
		Если фрм<>Ложь Тогда
			фрм.сбисПослеОтправкиПакетов(Кэш);	
		КонецЕсли;
		Если Не Кэш.ТихийРежим Тогда
			Если Кэш.РезультатОтправки.Свойство("ФормаОтправки") Тогда
				сбисПолучитьФорму(Кэш.РезультатОтправки.ФормаОтправки).ПослеОтправки(Кэш);
			Иначе
				фрм = Кэш.ГлавноеОкно.сбисНайтиФормуФункции("ПоказатьРезультатОтправки","ФормаРезультатОтправки","", Кэш);
				фрм.ПоказатьРезультатОтправки(Кэш);
				Если Кэш.РезультатОтправки.Свойство("ОтправкаИзПересылки") Тогда
					сбисПолучитьФорму("ФормаПересылкаПакетов").ПослеОтправки(Кэш);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Истина;
КонецФункции
&НаКлиенте
Функция ОтправитьПартиюПакетов(Кэш, МассивПакетов) Экспорт
	// Функция выполняет отправку партии подготовленных пакетов документов через форму интеграции. Так же отправляет каталог номенклатуры.
	Кэш.ФормаОтправки.ОтправитьПакетыДокументов(Кэш, МассивПакетов);
	Если Кэш.РезультатОтправки.Свойство("ПереотправитьПартию") Тогда
		МассивНеотправленныхПакетов = Новый Массив;
		Для Каждого Пакет Из МассивПакетов Цикл
			Если НЕ Пакет.Свойство("Отправлен") Тогда
				МассивНеотправленныхПакетов.Добавить(Пакет);
			КонецЕсли;
		КонецЦикла;
		Кэш.ФормаОтправки.ОтправитьПакетыДокументов(Кэш, МассивНеотправленныхПакетов);
		Кэш.РезультатОтправки.Удалить("ПереотправитьПартию");
	КонецЕсли;
	Кэш.РезультатОтправки.ВсегоПакетов = Кэш.РезультатОтправки.ВсегоПакетов+МассивПакетов.Количество();
	МассивПакетов.Очистить();
	СтруктураИниФайла = Кэш.Ини;
	//Если	Кэш.Парам.ОтправлятьНоменклатуруСДокументами = Истина
	//	И	СтруктураИниФайла.Свойство("Номенклатура",СтруктураИниФайла)
	//	И	СтруктураИниФайла.Свойство("мФайл",СтруктураИниФайла)
	//	И	СтруктураИниФайла.Свойство("Номенклатура",СтруктураИниФайла) Тогда
	//	ИниНоменклатура = Новый Структура;
	//	Кэш.ОбщиеФункции.сбисСкопироватьСтруктуруНаКлиенте(ИниНоменклатура, СтруктураИниФайла);
	//	КаталогОтправлен = Кэш.ОбщиеФункции.сбисСформироватьОтправитьКаталогТоваров(Кэш, Новый Структура("СписокНоменклатуры, Организация",Кэш.СписокНоменклатуры),ИниНоменклатура,Новый Структура("РеквизитСопоставленияНоменклатуры", Кэш.КэшЗначенийИни.РеквизитСопоставленияНоменклатуры));
	//	Кэш.СписокНоменклатуры.Очистить();
	//КонецЕсли;
КонецФункции
&НаКлиенте
Функция АктивироватьСертификатыЗавершение(Результат, ДополнительныеПараметры) Экспорт
// Функция вызывается после ввода пин-кода (если требовалось активировать серверные сертификаты). 
// Отправляет сформированную партию пакетов и если есть еще несформированные, вызывает дальнейшее формирование.
	Кэш = ДополнительныеПараметры.Кэш;
	РезультатОтправки = ДополнительныеПараметры.РезультатОтправки;
	Если Результат = Неопределено Тогда   // не ввели пин-код
		ТекстОшибки = "Не активирован сертификат для подписания документов.";
		Сообщить(ТекстОшибки);
		//ЭлементСписка = Кэш.РезультатОтправки.ТипыОшибок.НайтиПоЗначению(ТекстОшибки);
		//Если ЭлементСписка=Неопределено Тогда
		//	Кэш.РезультатОтправки.ТипыОшибок.Добавить(ТекстОшибки, КоличествоПакетов);
		//Иначе
		//	ЭлементСписка.Представление = Число(ЭлементСписка.Представление)+КоличествоПакетов;
		//КонецЕсли;
		сбисСпрятатьСостояние(Кэш.ГлавноеОкно);
		Возврат Ложь;
	Иначе
		ТекущийСертификат = РезультатОтправки.СписокСертификатов[Результат.счСертификатов].Значение;
		ТекущийСертификат.Вставить("КодАктивации",Результат.ПинКод);
		СчетчикВведенныхПинкодов = СчетчикВведенныхПинкодов+1;
		Если СчетчикВведенныхПинкодов = РезультатОтправки.СписокСертификатов.Количество() Тогда   // если ввели все пин-коды
			Если Кэш.Интеграция.АктивироватьСерверныеСертификаты(Кэш, РезультатОтправки.СписокСертификатов) = Ложь Тогда
				Возврат Ложь;
			КонецЕсли;
			Для Каждого Элемент Из РезультатОтправки.ИННОтправителей Цикл
				РезультатОтправки.УжеАктивированы.Добавить(Элемент.Значение);
			КонецЦикла;
			ИННОтправителей = Новый СписокЗначений;
			ОтправитьПартиюПакетов(Кэш, РезультатОтправки.МассивПакетов); // отправляем уже готовую партию
			МассивПакетов = Новый Массив;
			// отправляем остальные подготовленные пакеты (или выводим результат, если уже все отправили)
			ПромежуточныйРезультатОтправки = ОтправитьПодготовленныеДокументы(Кэш, РезультатОтправки.МассивПодготовленныхПакетов,РезультатОтправки.счПодготовленныхПакетов,РезультатОтправки.МассивСтрок,РезультатОтправки.счСтрок, МассивПакетов, ИННОтправителей, РезультатОтправки.УжеАктивированы, РезультатОтправки.ПоследняяПартия);	
			Если ТипЗнч(ПромежуточныйРезультатОтправки) = Тип("Структура") Тогда
				СчетчикВведенныхПинкодов = 0;
				счСертификатов = 0;
				Для Каждого Элемент Из ПромежуточныйРезультатОтправки.СписокСертификатов Цикл
					Сертификат = Элемент.Значение;
					Если Сертификат.Ключ.СпособАктивации<>"СтатическийКод" Тогда
						Кэш.Интеграция.ПолучитьКодАктивацииСертификата(Кэш, Сертификат);				
					КонецЕсли;
					СертификатИмя = "Введите код активации сертификата "+Кэш.ОбщиеФункции.СокращенноеФИО(Кэш,Сертификат.ФИО)+?(Сертификат.Свойство("Должность"),"("+Сертификат.Должность+")", "")+", "+Сертификат.Название+?(Сертификат.Свойство("ИНН"),"(ИНН "+Сертификат.ИНН+")","");
					ОткрытьФорму("ВнешняяОбработка.СБИС.Форма.ФормаВводаПинкода",Новый Структура("СертификатИмя,счСертификатов",СертификатИмя,счСертификатов),ЭтаФорма,,,,Новый ОписаниеОповещения("АктивироватьСертификатыЗавершение",ЭтаФорма,Новый Структура("Кэш,РезультатОтправки",Кэш,ПромежуточныйРезультатОтправки)));	
					счСертификатов = счСертификатов+1;
				КонецЦикла;
				Возврат Истина;
			КонецЕсли;
			//Формируем остальные пакеты и отправляем их
			Если РезультатОтправки.Свойство("счСтрок") и РезультатОтправки.счСтрок<РезультатОтправки.МассивСтрок.Количество() Тогда
				РезультатОтправки = ОтправитьДокументыПоМассивуСтрок(Кэш,РезультатОтправки.МассивСтрок,РезультатОтправки.счСтрок,МассивПакетов, ИННОтправителей, РезультатОтправки.УжеАктивированы);
				Если ТипЗнч(РезультатОтправки) = Тип("Структура") Тогда
					СчетчикВведенныхПинкодов = 0;
					счСертификатов = 0;
					Для Каждого Элемент Из РезультатОтправки.СписокСертификатов Цикл
						Сертификат = Элемент.Значение;
						Если Сертификат.Ключ.СпособАктивации<>"СтатическийКод" Тогда
							Кэш.Интеграция.ПолучитьКодАктивацииСертификата(Кэш, Сертификат);				
						КонецЕсли;
						СертификатИмя = "Введите код активации сертификата "+Кэш.ОбщиеФункции.СокращенноеФИО(Кэш,Сертификат.ФИО)+?(Сертификат.Свойство("Должность"),"("+Сертификат.Должность+")", "")+", "+Сертификат.Название+?(Сертификат.Свойство("ИНН"),"(ИНН "+Сертификат.ИНН+")","");
						ОткрытьФорму("ВнешняяОбработка.СБИС.Форма.ФормаВводаПинкода",Новый Структура("СертификатИмя,счСертификатов",СертификатИмя,счСертификатов),ЭтаФорма,,,,Новый ОписаниеОповещения("АктивироватьСертификатыЗавершение",ЭтаФорма,Новый Структура("Кэш,РезультатОтправки",Кэш,РезультатОтправки)));	
						счСертификатов = счСертификатов+1;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецФункции
&НаКлиенте
Процедура ПрерываниеПользователемФормированияДокументов()
	// Если пользователь прервал формирование документов, прячем состояние
	ГлавноеОкно = сбисПолучитьФорму("ФормаГлавноеОкно");
	сбисСпрятатьСостояние(ГлавноеОкно);	
КонецПроцедуры
//---------------------------------------------------------

&НаКлиенте
Функция ПрочитатьДокумент(Кэш,Контекст) Экспорт
	// Функция перебирает мФайлы в файле настроек и для каждого вызывает функцию формирования структуры документа из соответствующей формы Файл_...	
	// Все вложения из состава пакета добавляем в первый пакет, сформированный по строке документов
	// на случай, если по одному из вложений формируется сразу несколько пакетов
	Если Контекст.МассивПакетов.Количество()>0 Тогда
		Контекст.СоставПакета = Контекст.МассивПакетов[0];
	Иначе
		Контекст.Вставить("СоставПакета",Новый Структура);
		Контекст.СоставПакета.Вставить("Вложение",Новый Массив);
	КонецЕсли;
	Контекст.Вставить("ФайлДанные", Новый Структура);
	ВсеВыгрузилось = Истина;
	Для Каждого Файл Из Контекст.ДокументДанные.мФайл Цикл
		Файл = Файл.Значение;
		Контекст.ФайлДанные = Файл;
		Файл.Файл_Формат = Кэш.ОбщиеФункции.РассчитатьЗначение("Файл_Формат", Файл, Кэш);
		Файл_Формат = Кэш.ОбщиеФункции.сбисЗаменитьНедопустимыеСимволы(Файл.Файл_Формат);
		Файл_ВерсияФормата = Кэш.ОбщиеФункции.сбисЗаменитьНедопустимыеСимволы(Файл.Файл_ВерсияФормата);
		Если Файл_Формат = "Конверт" И Контекст.СоставПакета.Свойство("Конверт") Тогда     // если конверт уже есть, переходим к следующему мФайлу
			Продолжить;
		КонецЕсли;
		Если Файл.Свойство("ФормаФормирования") Тогда
			ФормаФормирования = Файл.ФормаФормирования;
		Иначе
			ФормаФормирования = "Файл_"+Файл_Формат+"_"+Файл_ВерсияФормата;
		КонецЕсли;
		// << alo 3.03
		ОсновнаяФормаФормирования = "Файл_Шаблон" + ?(Файл_ВерсияФормата = "3_01", "", "_" + Файл_ВерсияФормата);
		фрм = Кэш.ГлавноеОкно.сбисНайтиФормуФункции("ПолучитьДанныеИзДокумента1С",ФормаФормирования,ОсновнаяФормаФормирования,Кэш);
		Если фрм = Ложь Тогда
			Если Кэш.Свойство("РезультатОтправки") Тогда
				Кэш.РезультатОтправки.НеСформировано = Кэш.РезультатОтправки.НеСформировано+1;
				Кэш.РезультатОтправки.ОшибкиДоОтправки = Кэш.РезультатОтправки.ОшибкиДоОтправки + 1;
				Кэш.ОбщиеФункции.ДобавитьОшибкуВРезультатОтправки(Кэш, "Документ не сформирован", "Для документа "+строка(Контекст.Документ)+" не найдена форма формирования электронного документа в формате "+Файл_Формат+", версии "+Файл.Файл_ВерсияФормата, Контекст.Документ, 726)
			Иначе
				Сообщить("Для документа "+строка(Контекст.Документ)+" не найдена форма формирования электронного документа в формате "+Файл_Формат+", версии "+Файл.Файл_ВерсияФормата);
			КонецЕсли;	
			Возврат Ложь;
		КонецЕсли;
		Если Не фрм.ПолучитьДанныеИзДокумента1С(Кэш,Контекст) Тогда //если хотябы что-то не выгрузилось - отбой
			ВсеВыгрузилось = Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Если Контекст.МассивПакетов.Количество()>0 Тогда
		Контекст.МассивПакетов[0] = Контекст.СоставПакета;
	Иначе
		Контекст.МассивПакетов.Вставить(0, Контекст.СоставПакета);
	КонецЕсли;
	
	Возврат ВсеВыгрузилось;
КонецФункции
&НаКлиенте
Функция ПрочитатьТабличнуюЧасть(Кэш,Контекст) Экспорт
	// Функция формирует табличную часть документа
	// Используется при формировании таб части СФ из документов-оснований
	Контекст.Вставить("СписокТЧ", Новый СписокЗначений);  // список ТЧ, чтобы одна и та же таб. часть дважды не попадала в документ
	Для Каждого Файл Из Контекст.ДокументДанные.мФайл Цикл
		Файл = Файл.Значение;
		Контекст.ФайлДанные = Файл;
		Файл.Файл_Формат = Кэш.ОбщиеФункции.РассчитатьЗначение("Файл_Формат", Файл, Кэш);
		Файл_Формат = Файл.Файл_Формат;
		Файл_ВерсияФормата = СтрЗаменить(СтрЗаменить(Файл.Файл_ВерсияФормата,".","_"), " ", "");
		Если Файл_Формат = "Конверт" Тогда     // Конверт пропускаем
			Продолжить;
		КонецЕсли;
		Если Файл.Свойство("ФормаФормирования") Тогда
			ФормаФормирования = Файл.ФормаФормирования;
		Иначе
			ФормаФормирования = "Файл_"+Файл_Формат+"_"+Файл_ВерсияФормата;
		КонецЕсли;    
		
		фрм = Кэш.ГлавноеОкно.сбисНайтиФормуФункции("ПолучитьТабличнуюЧастьДокумента1С",ФормаФормирования,"Файл_Шаблон",Кэш);	
		фрм.ПолучитьТабличнуюЧастьДокумента1С(Кэш,Контекст)
	КонецЦикла;
	Контекст.Удалить("СписокТЧ");
	Возврат Истина;
КонецФункции		

// Загрузка документов
&НаКлиенте
Функция ЗагрузитьДокументыВ1С(Кэш, СписокОтмеченныхДокументов, ДополнительныеПараметры=Неопределено) Экспорт
	// Загружает отмеченные пакеты документов в 1С	

	//Режим 0 Перезаполнить
	//Режим 1 Создать новые
	//Режим 2 Отменить
	//Режим 3 Загружать ещё не загруженные
	РежимДокументов = 3;
	//Режим 0 Документ не загружается, если нет сопоставления.
	//Режим 1 Для несопоставленных позиций создавать карточки номенклатуры и контрагента.
	//Режим 2 В табличную часть загружать только сопоставленную номенклатуру.                             
	РежимНоменклатуры = 1;
	Если Не ДополнительныеПараметры = Неопределено Тогда
		Если ДополнительныеПараметры.Свойство("РежимДокументов") Тогда
			РежимДокументов = ДополнительныеПараметры.РежимДокументов;
		КонецЕсли;
		Если ДополнительныеПараметры.Свойство("РежимНоменклатуры") Тогда
			РежимНоменклатуры = ДополнительныеПараметры.РежимНоменклатуры;
		КонецЕсли;
	КонецЕсли;
	
	Обновлять = Ложь;
	МестныйКэш = Кэш;
	ГлавноеОкно = Кэш.ГлавноеОкно;
	Всего = СписокОтмеченныхДокументов.Количество();
	Загружено = 0;
	сч = 0;
	
	РезультатДействия = МестныйКэш.ОбщиеФункции.РезультатДействия_Получить(МестныйКэш, Новый Структура("ПредставлениеОперации, ФормаВызова", "ЗагрузкаДокумента", "Документ_Шаблон"));
	МестныйКэш.Вставить("РезультатДействия", РезультатДействия);
	ПараметрыЗагрузки = Новый Структура("РежимДокументов, РежимНоменклатуры", РежимДокументов, РежимНоменклатуры);
	//Если необходимо внести какие-то изменения, ответив на вопрос, то массово не делаем. Только на форме просмотра.
	ДополнительныеПараметрыЗагрузки = Новый Структура("ОтветНаИзмененияВИсходныйДокумент, ФормаВызова", КодВозвратаДиалога.Отмена, "Документ_Шаблон");
	Для Каждого Строка из СписокОтмеченныхДокументов Цикл
		сч = сч + 1;
		сбисПоказатьСостояние("Загрузка документов",ГлавноеОкно,Мин(100,Окр(сч*100/Всего)));
		МассивПакетов = Кэш.Текущий.Форма.ПодготовитьСтруктуруДокумента(Строка.Значение, Кэш);
		МестныйКэш.ОбщиеФункции.РезультатДействия_ДобавитьВремя(Кэш, РезультатДействия, "ПолучениеДанных");
		Для Каждого Пакет Из МассивПакетов Цикл
			ПолныйСоставПакета = МестныйКэш.ОбщиеФункции.РазобратьСтруктуруДокументаСбис(Пакет, Кэш);
			ПолныйСоставПакета = МестныйКэш.ОбщиеФункции.ЗаполнитьРеквизитыОснованийПакета(ПолныйСоставПакета, МестныйКэш); // пока SDK не возвращает дату, номер док. основания
			МестныйКэш.ОбщиеФункции.РезультатДействия_ДобавитьВремя(Кэш, РезультатДействия, "Подготовка");
			ПолныйСоставПакета.Вставить("НоменклатураСопоставлена",Истина);
			СписокВложений = Новый Массив;
			Для Каждого Вложение Из ПолныйСоставПакета.Вложение Цикл
				ДанныеДляЗагрузки = МестныйКэш.ОбщиеФункции.ЗаполнитьДанныеДляЗагрузкиПоУмолчанию(Кэш,ПолныйСоставПакета,Вложение,ДополнительныеПараметрыЗагрузки);
				ВложениеДобавить = Новый СписокЗначений;
				ВложениеДобавить.Добавить(Вложение);
				ДанныеДляЗагрузки.Вставить("Вложение", ВложениеДобавить);
				СписокВложений.Добавить(ДанныеДляЗагрузки);
			КонецЦикла;
			Если Не СписокВложений.Количество() Тогда 
				Продолжить; 
			КонецЕсли;
			//Здесь не используем возвращаемый результат, так как он в созданном результате действия. Его и возвращаем в конце.
			МестныйКэш.ОбщиеФункции.СоздатьПерезаполнитьДокументы(Кэш,ПолныйСоставПакета,СписокВложений,ПараметрыЗагрузки,ДополнительныеПараметрыЗагрузки);
		КонецЦикла;
	КонецЦикла;
	сбисСпрятатьСостояние(ГлавноеОкно);
	Возврат	РезультатДействия;	
КонецФункции
&НаКлиенте
Функция СоздатьДокумент(Кэш, Вложение, Ини, СоставПакета, МассивОснований, Документ1С = Неопределено) Экспорт
// Функция заполняет документ 1С данными из файла, проставляет идентификаторы и статус документа СБИС	
	МестныйКэш		= Кэш;
	ГлавноеОкно		= Кэш.ГлавноеОкно;
	СтруктураФайла	= Вложение.СтруктураФайла;
	
	СписокДокументов		= Новый СписокЗначений;
	СтруктураДанныхДокумента= Новый Структура;
	//AU таким костыльным способом передаём строку детализации внуть метода.
	ДанныеДетализации = Кэш.ОбщиеФункции.РезультатДействия_ИзвлечьВременныеДанные(Кэш);
	Кэш.ОбщиеФункции.сбисСкопироватьСтруктуруНаКлиенте(СтруктураДанныхДокумента, Ини);
	ТипДокумента = СообщитьИмяРеквизита(Ини.Документ.Значение);
	Если Документ1С = Неопределено и Кэш.парам.СопоставлятьПередЗагрузкой Тогда
		РеквизитыДляПоиска = Новый Структура;
		РеквизитыДляПоиска.Вставить("НашаОрганизация",	СоставПакета.НашаОрганизация);
		РеквизитыДляПоиска.Вставить("Контрагент",		?(СоставПакета.Свойство("Контрагент"),СоставПакета.Контрагент, Неопределено));
		РеквизитыДляПоиска.Вставить("Дата",				Вложение.Дата);
		РеквизитыДляПоиска.Вставить("Номер",			Вложение.Номер);
		фрмНайтиДок = Кэш.ГлавноеОкно.сбисНайтиФормуФункции("НайтиПодходящиеДокументыОпределенногоТипа","РаботаСДокументами1С",,Кэш);
		фрмНайтиДок.НайтиПодходящиеДокументыОпределенногоТипа(СписокДокументов, Ини, Кэш.Ини, Кэш.Парам, РеквизитыДляПоиска);
	КонецЕсли;
	Если СписокДокументов.Количество()=1 Тогда
		Документ1С = СписокДокументов[0].Значение;
		СтрокаСообщения	= "Найден соответствующий документ 1С "+строка(Документ1С);
		//AU если нет результата действия, то всё остаётся работать по старому алгоритму. Если есть, то анализ и демонстрация сообщений будет проводиться на уровне вызова.
		Если ДанныеДетализации.ЗаполнитьДетализацию Тогда
			ПараметыЗаполнения = Новый Структура("Ссылка, Тип, Состояние, Сообщение", Документ1С, "Документ." + ТипДокумента, "Найден.", СтрокаСообщения);
			Кэш.ОбщиеФункции.РезультатДействия_ДобавитьВРасшифровку(Кэш, "ЗагрузкаДокумента", ДанныеДетализации.СтрокаДетализации, ПараметыЗаполнения);			
		Иначе
			Сообщить("Для документа " + Вложение.Название + " н" + Сред(СтрокаСообщения, 1));
		КонецЕсли;
	Иначе
		Документ1С = ЗаполнитьДанныеДокумента1С(Кэш, СтруктураДанныхДокумента, СтруктураФайла, МассивОснований,СоставПакета, Вложение, Документ1С, ДанныеДетализации);
	КонецЕсли;
	Если Документ1С<>Неопределено Тогда
		СтруктураСвойств = Новый Структура("ДокументСБИС_Ид,ДокументСБИС_ИдВложения,ДокументСБИС_Статус", СоставПакета.Идентификатор,Вложение.Идентификатор,СоставПакета.Состояние.Название);
		Если Ини.Свойство("ВыборПараметрыДокумента") Тогда
			Контекст = Новый Структура("Ини, Документ, СтруктураФайла,СоставПакета,ИниКонфигурация", Ини, Документ1С, СтруктураФайла,СоставПакета,МестныйКэш.Ини.Конфигурация);
			Для Каждого ЭлементВыбор Из Ини.ВыборПараметрыДокумента Цикл
				Контекст.Вставить("Ини", ЭлементВыбор.Значение);
				РезультатУсловия = РассчитатьЗначение("Условие", Контекст, Кэш);
				Если РезультатУсловия = Истина Тогда
					сбисЗаполнитьПараметрыДокумента(СтруктураСвойств, Ини, ЭлементВыбор.Значение, Документ1С, СтруктураФайла,СоставПакета, Кэш);	
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если Ини.Свойство("мПараметрыДокумента") Тогда
			сбисЗаполнитьПараметрыДокумента(СтруктураСвойств, Ини, Ини, Документ1С, СтруктураФайла,СоставПакета, Кэш);	
		КонецЕсли;			 
		фрм = ГлавноеОкно.сбисНайтиФормуФункции("ЗаписатьПараметрыДокументаСБИС",Кэш.ФормаРаботыСоСтатусами,"",Кэш);
		фрм.ЗаписатьПараметрыДокументаСБИС(СтруктураСвойств, Документ1С, Кэш.Ини.Конфигурация, ГлавноеОкно.КаталогНастроек);
		Если Кэш.парам.СостояниеЭД Тогда
			ПараметрыПоиска = Новый Структура;
			ПараметрыПоиска.Вставить("ИмяФункции",	"ДублироватьСостояние");
			ПараметрыПоиска.Вставить("КлючФорм",	"Статусы_СостоянияЭД");
			фрмЭД = Кэш.ОбщиеФункции.сбисНайтиФормуФункцииПодсистемы(Кэш, ПараметрыПоиска);
			Если Не фрмЭД = Ложь Тогда
				фрмЭД.ДублироватьСостояние(СоставПакета, Документ1С, Вложение.XMLДокумента, СтруктураФайла);  // alo Загрузка маркировки 
			КонецЕсли;
		КонецЕсли;
	Возврат Документ1С;
	КонецЕсли;
КонецФункции
&НаКлиенте
Функция сбисЗаполнитьПараметрыДокумента(СтруктураСвойств, Ини, РазделИниПараметры, Документ1С, СтруктураФайла,СоставПакета, Кэш)
	Для Каждого Элемент из РазделИниПараметры.мПараметрыДокумента Цикл
		Переменные = Новый Структура;
		мПараметры = Новый Структура;

		Если Элемент.Значение.Параметр_Значение.Свойство("Данные") Тогда
			Параметр_Значение = ЗаполнитьЗначениеРеквизитаИзФайла(Элемент.Значение.Параметр_Значение, СтруктураФайла, мПараметры, МестныйКэш);						
		КонецЕсли;
		Если Элемент.Значение.Параметр_Имя.Свойство("Вычислить") и (Найти(Элемент.Значение.Параметр_Имя.Вычислить,"'")>0 или Найти(Элемент.Значение.Параметр_Имя.Вычислить,"{")>0) Тогда
			Контекст = Новый Структура("Ини, Документ, Переменные, СтруктураФайла,СоставПакета,ИниКонфигурация", Ини, Документ1С, Переменные, СтруктураФайла,СоставПакета,МестныйКэш.Ини.Конфигурация);
			Параметр_Имя = РассчитатьЗначение(Элемент.Значение.Параметр_Имя.Вычислить,Контекст,МестныйКэш);
		КонецЕсли;	
		Если ЗначениеЗаполнено(Параметр_Значение) и ЗначениеЗаполнено(Параметр_Имя) Тогда
			СтруктураСвойств.Вставить(Параметр_Имя, Параметр_Значение);
		КонецЕсли;
	КонецЦикла;	
КонецФункции

////////////////////////////////////////////////////
////////////////Расчет по ини документа/////////////
////////////////////////////////////////////////////

&НаКлиенте
Функция ЗаполнитьДаннымиСтруктурыФайлаСтруктуруДокумента(Кэш, СтруктураФайла, Ини, ДокОбъект, МассивОснований,СоставПакета, Вложение) Экспорт
	// Функция заполняет структуру документа 1С по файлу настроек
	МестныйКэш		= Кэш;
	ПеременныеДок	= Новый Структура;
	Ограничения		= Новый Структура;
	Контекст		= Новый Структура(	"Ини,	Документ,	Переменные,		СтруктураФайла,	Вложение,	СоставПакета,	ИниКонфигурация", 
										Ини,	ДокОбъект,	ПеременныеДок,	СтруктураФайла,	Вложение,	СоставПакета,	МестныйКэш.Ини.Конфигурация);
	//Получим строку ключей шапки ини для быстрого формирования контекста строки ТЧ									
	КлючиИниВерхнегоУровня = "";									
	Для Каждого Элемент Из Ини Цикл
		Если Элемент.Ключ = "мТаблДок" Тогда
			Продолжить;
		КонецЕсли;
		КлючиИниВерхнегоУровня = КлючиИниВерхнегоУровня + Элемент.Ключ + ",";
	КонецЦикла;
	КлючиИниВерхнегоУровня = Сред(КлючиИниВерхнегоУровня, 0, СтрДлина(КлючиИниВерхнегоУровня) - 1);
	Для Каждого Элемент Из Ини Цикл
		Если Элемент.Значение.Свойство("Значение") Тогда
			//AU добавлена проверка значения "Данные" для возможности отключения расчета атрибута пользовательской ини
			Если Элемент.Значение.Свойство("Данные") И ЗначениеЗаполнено(Элемент.Значение.Данные) Тогда
				ЗначениеРеквизита = ЗаполнитьЗначениеРеквизитаИзФайла(Элемент.Значение, СтруктураФайла, ДокОбъект, МестныйКэш);						
				Элемент.Значение.Вставить("РассчитанноеЗначение", ЗначениеРеквизита);
			КонецЕсли;
			ВычислитьЗначение=Неопределено;
			Если	Элемент.Значение.Свойство("Вычислить",ВычислитьЗначение)
				И	(	Найти(ВычислитьЗначение,"'") = 1
					Или Найти(ВычислитьЗначение,"{") = 1
					Или	Найти(ВычислитьЗначение,"^") = 1) Тогда//UAA обновлено условие в связи с багом. Если значение вычисляется на сервере, то должно быть ВычислитьНаСервере. Проверка по 1 символу
				//березкин
				ЗначениеРеквизита = РассчитатьЗначение(ВычислитьЗначение,Контекст,МестныйКэш);
				ДокОбъект = Контекст.Документ;// Если в функции заполняются не только вычисляемый реквизит, но и другие данные документа, которые попадают в Контекст.Документ
				//
				ЗаполнитьЗначениеРеквизита(ЗначениеРеквизита, Элемент.Значение.Значение, ДокОбъект, ПеременныеДок);	
				Элемент.Значение.Вставить("РассчитанноеЗначение", ЗначениеРеквизита);
			КонецЕсли;
			Продолжить;
		ИначеЕсли Элемент.Ключ = "мСторона" Тогда
			КонтрагентРоль	= РассчитатьЗначение("Контрагент_Роль",	Контекст, МестныйКэш);
			ОрганизацияРоль	= РассчитатьЗначение("Организация_Роль",Контекст, МестныйКэш);
			// сначала ищем организацию, т.к. она может потребоваться при поиске контрагента (при определенной настройке прав)
			Если Элемент.Значение.Свойство(ОрганизацияРоль) Тогда
				ЗначениеПараметра = МестныйКэш.ОбщиеФункции.НайтиОрганизациюИзДокументаСБИС(МестныйКэш.Ини.Конфигурация, МестныйКэш.ОбщиеФункции.РассчитатьЗначениеИзСтруктуры(Элемент.Значение[ОрганизацияРоль].Сторона.Данные,СтруктураФайла));
				Если МестныйКэш.Ини.Конфигурация.Свойство("ЗапросКонтрагента") и МестныйКэш.Ини.Конфигурация.ЗапросКонтрагента.Свойство("ОграничениеПоОрганизации") и НРег(МестныйКэш.Ини.Конфигурация.ЗапросКонтрагента.ОграничениеПоОрганизации)="да"  Тогда
					Ограничения = Новый Структура("Организация",ЗначениеПараметра);
				КонецЕсли;
				ЗаполнитьЗначениеРеквизита(ЗначениеПараметра, Элемент.Значение[ОрганизацияРоль].Сторона.Значение, ДокОбъект, ПеременныеДок);	
			КонецЕсли;
			Для Каждого Сторона Из Элемент.Значение Цикл
				Если Сторона.Ключ <> ОрганизацияРоль Тогда
					Если Сторона.Значение.Сторона.Свойство("Данные") Тогда
						СтруктураСтороны = МестныйКэш.ОбщиеФункции.РассчитатьЗначениеИзСтруктуры(Сторона.Значение.Сторона.Данные,СтруктураФайла);
						Если ЗначениеЗаполнено(СтруктураСтороны) Тогда
							//ЗначениеПараметра = НайтиСоздатьКонтрагента(СтруктураСтороны, Сторона.Значение);
							Если ЗначениеЗаполнено(Ограничения) Тогда
								СтруктураСтороны.Вставить("Ограничения",Ограничения);
							КонецЕсли;
							Если Сторона.Значение.Сторона.Свойство("Тип") и Найти(Сторона.Значение.Сторона.Тип, "Организации")>0 Тогда
								ЗначениеПараметра = МестныйКэш.ОбщиеФункции.НайтиОрганизациюИзДокументаСБИС(МестныйКэш.Ини.Конфигурация, СтруктураСтороны);
							Иначе
								ЗначениеПараметра = МестныйКэш.ОбщиеФункции.НайтиКонтрагентаИзДокументаСБИС(МестныйКэш.Ини.Конфигурация, СтруктураСтороны, Ини);
							КонецЕсли;
							Если Сторона.Ключ = КонтрагентРоль Тогда
								Если Вложение.Свойство("РучноеИзменение") И Вложение.РучноеИзменение = Истина и Вложение.Свойство("Контрагент1С") и ЗначениеЗаполнено(Вложение.Контрагент1С) Тогда
									ЗначениеПараметра = Вложение.Контрагент1С;
								КонецЕсли;
							КонецЕсли;
							ЗаполнитьЗначениеРеквизита(ЗначениеПараметра, Сторона.Значение.Сторона.Значение, ДокОбъект, ПеременныеДок);
						КонецЕсли;
					КонецЕсли;
					Если Сторона.Значение.Сторона.Свойство("Вычислить") Тогда
						//ЗначениеПараметра = НайтиСоздатьКонтрагента(РассчитатьЗначение(Сторона.Значение.Сторона.Вычислить,Новый Структура("Ини, Документ, Переменные, СтруктураФайла,СоставПакета", Ини, ДокОбъект, ПеременныеДок, СтруктураФайла,СоставПакета),МестныйКэш), Сторона.Значение);
						ЗначениеПараметра = РассчитатьЗначение(Сторона.Значение.Сторона.Вычислить, Контекст, МестныйКэш);
						Если ТипЗнч(ЗначениеПараметра) = Тип("Структура") Тогда  // структура в формате СБИС
							ЗначениеПараметра = МестныйКэш.ОбщиеФункции.НайтиКонтрагентаИзДокументаСБИС(МестныйКэш.Ини.Конфигурация, ЗначениеПараметра, Ини);
						КонецЕсли;
						ЗаполнитьЗначениеРеквизита(ЗначениеПараметра, Сторона.Значение.Сторона.Значение, ДокОбъект, ПеременныеДок);
					КонецЕсли;
				КонецЕсли;	
			КонецЦикла;
		ИначеЕсли Элемент.Ключ = "мТаблДок" Тогда
			ИмяПервойТЧ = "";
			мТаблДокРассчитанноеЗначение = Новый Структура;
			Для Каждого ТабЧасть Из Элемент.Значение Цикл
				ТабЧастьРассчитанноеЗначение = Новый Массив;
				мТаблДокРассчитанноеЗначение.Вставить(ТабЧасть.Ключ, ТабЧастьРассчитанноеЗначение);
				ПутьТаблДок = ТабЧасть.Значение;
				Если Не	(	ПутьТаблДок.Свойство("ТаблДок", ПутьТаблДок)
						И	ПутьТаблДок.Свойство("Данные",  ПутьТаблДок)) Тогда
					ПутьТаблДок = "Файл.Документ.ТаблДок.СтрТабл";
				КонецЕсли;
				ТаблДок = МестныйКэш.ОбщиеФункции.РассчитатьЗначениеИзСтруктуры(ПутьТаблДок, СтруктураФайла);
				Если Не ЗначениеЗаполнено(ТаблДок) Тогда
					ТаблДок = Новый Массив;//При заполнении пустого документа
					Продолжить;
				КонецЕсли;
				Если ПустаяСтрока(ИмяПервойТЧ) Тогда
					ИмяПервойТЧ = ТабЧасть.Ключ;
				КонецЕсли;
				НомерСтрокиДокумента = 0;
				Для Каждого Строка Из ТаблДок Цикл
					Если Строка.Свойство("НеЗагружать") Тогда
						Продолжить;
					КонецЕсли;
					//Создаем поверхностную копию ини с шапкой и добиваем её контекстом строки.
					КонтекстИниСтроки	= Новый Структура(КлючиИниВерхнегоУровня); 
					Переменные			= Новый Структура;
					ЗаполнитьЗначенияСвойств(КонтекстИниСтроки, Ини);
					МестныйКэш.ОбщиеФункции.сбисСкопироватьСтруктуруНаКлиенте(КонтекстИниСтроки,	ТабЧасть.Значение);
					МестныйКэш.ОбщиеФункции.сбисСкопироватьСтруктуруНаКлиенте(Переменные,		ПеременныеДок);
					ИмяТЧ = Ини;
					Если	ИмяТЧ.Свойство("ИмяТЧ",		ИмяТЧ)
						И	ИмяТЧ.Свойство("Вычислить",	ИмяТЧ) Тогда
						ИмяТЧ = РассчитатьЗначение(ИмяТЧ, Новый Структура("Ини, Документ, СтрТабл, СтруктураФайла, Вложение,СоставПакета,ИниКонфигурация", Ини, , Строка, СтруктураФайла, Вложение, СоставПакета, МестныйКэш.Ини.Конфигурация), МестныйКэш);			
					Иначе  // если в ини не указано правило, в какую ТЧ класть номенклатуру, то все кладем в первую
						ИмяТЧ = ИмяПервойТЧ;
					КонецЕсли;

					Если Не ИмяТЧ = ТабЧасть.Ключ Тогда
						Продолжить;
					КонецЕсли;
					Если Не ДокОбъект.Свойство(ИмяТЧ) Тогда
						ДокОбъект.Вставить(ИмяТЧ, Новый массив);
					КонецЕсли;
					ТабЧастьРассчитанноеЗначение.Добавить(КонтекстИниСтроки);
					НоваяСтрокаДокумента	= Новый Структура;
					НомерСтрокиДокумента	= НомерСтрокиДокумента + 1;
					ТабЧастьЗначение		= ТабЧасть.Значение;
					Для Каждого Поле Из ТабЧастьЗначение Цикл								
						Если	Не	Лев(Поле.Ключ, 5) = "Выбор"
							И		Поле.Значение.Свойство("Значение") Тогда
							Продолжить;
						КонецЕсли;
						Для Каждого ПодРаздел Из Поле.Значение Цикл //Выбираем подузлы
							Если Не (ТипЗнч(ПодРаздел.Значение) = Тип("Структура") И ПодРаздел.Значение.Количество()) Тогда
								Продолжить;
							КонецЕсли;
							РезультатУсловия = Ложь;
							Если ПодРаздел.Значение.Свойство("Условие") = Истина Тогда
								КонтекстРасчетаВыбора = Новый Структура("Ини, Документ, Переменные, СтруктураФайла, Вложение, СоставПакета, ИниКонфигурация", ПодРаздел.Значение);
								ЗаполнитьЗначенияСвойств(КонтекстРасчетаВыбора, Контекст,,"Ини");
								РезультатУсловия = РассчитатьЗначение("Условие", КонтекстРасчетаВыбора, МестныйКэш);
								Если Не РезультатУсловия = Истина Тогда
									Продолжить;
								КонецЕсли;
								Для Каждого ПодЭлемент из ПодРаздел.Значение Цикл //Выбираем подузлы
									Если ПодЭлемент.Ключ <> "Условие" Тогда								
										ТабЧастьЗначение.Вставить(ПодЭлемент.Ключ, ПодЭлемент.Значение);
										КонтекстИниСтроки.Вставить(ПодЭлемент.Ключ, ПодЭлемент.Значение);
									КонецЕсли;	
								КонецЦикла;								
							КонецЕсли;	
						КонецЦикла;	
					КонецЦикла;
					КонтекстРасчета = Новый Структура(
						"СтруктураФайла, Кэш, СоставПакета, Вложение, Переменные,Ини,				СтрТабл,				СтрокаФайла,Документ, ИниКонфигурация,		ТекущееПолеКлюч, ТекущееПолеИни", 
						 СтруктураФайла, Кэш, СоставПакета, Вложение, Переменные,КонтекстИниСтроки,	НоваяСтрокаДокумента,	Строка,		ДокОбъект,Кэш.Ини.Конфигурация);
					Для Каждого Поле Из ТабЧастьЗначение Цикл
						КонтекстРасчета.ТекущееПолеКлюч = Поле.Ключ;
						КонтекстРасчета.ТекущееПолеИни = КонтекстИниСтроки[Поле.Ключ];
						СбисВычислитьПолеНаКлиенте(Кэш, КонтекстРасчета);
					КонецЦикла;
					//КонтекстИниСтроки.Вставить("РассчитанноеЗначение", НоваяСтрокаДокумента);
					ДокОбъект[ИмяТЧ].Добавить(НоваяСтрокаДокумента);
					Строка.Вставить("ИмяТЧ",ИмяТЧ);
					Строка.Вставить("НомерСтрокиТЧ", НомерСтрокиДокумента - 1);
				КонецЦикла
			КонецЦикла;
			Элемент.Значение.Вставить("РассчитанноеЗначение", мТаблДокРассчитанноеЗначение);
		ИначеЕсли Элемент.Ключ = "мОснование" Тогда
			Для каждого Основание Из Элемент.Значение Цикл
				ТипДок = Сред(Ини.Документ.Значение, Найти(Ини.Документ.Значение, ".")+1);
				ИмяРеквизита = Сред(Основание.Значение.Основание.Значение, Найти(Основание.Значение.Основание.Значение, ".")+1);
				ЗаполнитьСвязанныеДокументы(ТипДок, ИмяРеквизита, Основание.Значение, ДокОбъект, МассивОснований);
				Контекст.Документ = ДокОбъект;//Обновим связь с документа в контексте, так как могло измениться после возвращения с сервера.
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	ЗаполнитьДаннымиСтруктурыФайлаСтруктуруДокументаНаСервере(СтруктураФайла, ТаблДок, Ини, ПеременныеДок, ДокОбъект);
КонецФункции

//Функция заполняет структуру документа 1С по файлу настроек
&НаСервереБезКонтекста
Функция ЗаполнитьДаннымиСтруктурыФайлаСтруктуруДокументаНаСервере(Знач СтруктураФайла, Знач ТаблДок, Знач Ини, Знач ПеременныеДок, ДокОбъект)
	АргументыРассчитать = Новый Структура("Документ, СтруктураФайла, Переменные, Ини", ДокОбъект, СтруктураФайла, ПеременныеДок, Ини);	
	Для Каждого КлючИЗначение Из Ини Цикл
		СбисВычислитьПолеНаСервере(КлючИЗначение.Значение, АргументыРассчитать, ДокОбъект);
	КонецЦикла;
	
	мТаблДокИни		= Ини;
	мТаблДокКонтекст= Неопределено;
	Если	Не мТаблДокИни.Свойство("мТаблДок",				мТаблДокИни)
		Или	Не мТаблДокИни.Свойство("РассчитанноеЗначение",	мТаблДокКонтекст)Тогда
		Возврат Неопределено;
	КонецЕсли;
	Для Каждого ТабЧасть Из мТаблДокИни Цикл
		Если ТабЧасть.Ключ = "РассчитанноеЗначение" Тогда
			Продолжить;
		КонецЕсли;
		ТабЧастьКонтекст = мТаблДокКонтекст[ТабЧасть.Ключ];
		ИндексТч = -1;
		Для Каждого СтрокаТЧ Из ТаблДок Цикл
			Если	СтрокаТЧ.Свойство("НеЗагружать")
				Или Не	(	СтрокаТЧ.Свойство("ИмяТЧ")
						И	СтрокаТЧ.ИмяТЧ = ТабЧасть.Ключ) Тогда
				Продолжить;
			КонецЕсли;
			ДокТч = ДокОбъект[СтрокаТЧ.ИмяТЧ];
			ИндексТч = ИндексТч + 1;
			//СтрокаТч_Ини = ТабЧастьКонтекст[ИндексТЧ];
			
			АргументыРассчитать.Вставить("Переменные",	Новый Структура);
			АргументыРассчитать.Вставить("СтрокаФайла",	СтрокаТЧ);
			АргументыРассчитать.Вставить("СтрТабл", 	ДокТч[СтрокаТЧ.НомерСтрокиТЧ]);
			АргументыРассчитать.Вставить("Ини", 		ТабЧастьКонтекст[ИндексТЧ]);
			//АргументыРассчитать.Вставить("СтрТабл", 	СтрокаТч_Ини.РассчитанноеЗначение);
			//АргументыРассчитать.Вставить("Ини", 		СтрокаТч_Ини);
			сбисСкопироватьСтруктуру(АргументыРассчитать.Переменные,ПеременныеДок); 	// в переменные по строке кладем общие переменные по документу
			
			Для Каждого КлючИЗначениеТЧ Из ТабЧасть.Значение Цикл
				//Составные узлы могут формировать строки в ту же ТЧ, откуда вызываются. 
				СбисВычислитьПолеНаСервере(АргументыРассчитать.Ини[КлючИЗначениеТЧ.Ключ], АргументыРассчитать, АргументыРассчитать.СтрТабл);
				Если КлючИЗначениеТЧ.Ключ = "ДобавлятьСтроку" Тогда
					АргументыРассчитать.СтрТабл.Вставить("ДобавлятьСтроку", РассчитатьЗначениеНаСервере("ДобавлятьСтроку", АргументыРассчитать));
				КонецЕсли;
			КонецЦикла;
			//ДокОбъект[СтрокаТЧ.ИмяТЧ].Добавить(СтрокаТч_Ини.РассчитанноеЗначение);
			//Удалям строки после общего расчета. Некоторые функции требует строки ТЧ в процессе загрузки и должны быть сформированы на клиенте
			Шаг = 0;
			Пока Шаг < ДокТч.Количество() Цикл
				СбисДобавлятьСтроку = Неопределено;
				Если	ДокТч[Шаг].Свойство("ДобавлятьСтроку", СбисДобавлятьСтроку)
					И	СбисДобавлятьСтроку = Ложь Тогда
					ДокТч.Удалить(Шаг);
					Продолжить;
				КонецЕсли;
				Шаг = Шаг + 1;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
КонецФункции

//Вынесен общий код и проверки в отдельную функцию
&НаКлиенте
Процедура СбисВычислитьПолеНаКлиенте(Кэш, АргументыРассчитать)
	Перем РезультатРасчета;
	СбисПоле = АргументыРассчитать.ТекущееПолеИни;
	Если	Не	СбисПоле.Свойство("Значение")Тогда		
		Если ЭтоСложныйУзел_Клиент(Кэш, СбисПоле) Тогда//UAA заполнение составных узлов при загрузке в 1С.
			УзелНаРасчет = Кэш.ОбщиеФункции.СбисСкопироватьОбъектНаКлиенте(СбисПоле);
			РезультатРасчета = ОбработатьСложныйУзел_Клиент(Кэш, УзелНаРасчет, АргументыРассчитать.СтрокаФайла, АргументыРассчитать.Документ, АргументыРассчитать);
			//Для составных узлов заполним расчитанные значения, чтобы это попало дальше на сервер.
			//Заполнение в ДокОбъект происходит на сервере!
			//При необходимости обратиться к результату обсчёта составного узла, брать из Контекст.Ини.мТаблДок[РассчитанноеЗначение]
			Для Каждого РасчитанныйПодУзел Из РезультатРасчета Цикл
				СбисПоле[РасчитанныйПодУзел.Ключ].Вставить("РассчитанноеЗначение", РасчитанныйПодУзел.Значение["РассчитанноеЗначение"]);
			КонецЦикла;
		КонецЕсли;
	ИначеЕсли СбисПоле.Свойство("РассчитанноеЗначение", РезультатРасчета) Тогда
		//Расчитанное значение, ничего не делаем
	Иначе
		Если СбисПоле.Свойство("Данные") Тогда
			РезультатРасчета = МестныйКэш.ОбщиеФункции.РассчитатьЗначениеИзСтруктуры(СбисПоле.Данные, АргументыРассчитать.СтрокаФайла);
			Если СбисПоле.Свойство("Тип") Тогда//AU вынесена проверка наличия атрибута типа для всех значений для корректного обсчета формул.
				Если СбисПоле.Тип="Дата" И ЗначениеЗаполнено(РезультатРасчета) Тогда
					РезультатРасчета = Дата(Сред(РезультатРасчета,7,4),Сред(РезультатРасчета,4,2),Лев(РезультатРасчета,2));
				КонецЕсли;
			КонецЕсли;
			СбисПоле.Вставить("РассчитанноеЗначение", РезультатРасчета);
			ЗаполнитьЗначениеРеквизита(РезультатРасчета, СбисПоле.Значение, АргументыРассчитать.СтрТабл, АргументыРассчитать.Переменные);
		КонецЕсли;
		Если	СбисПоле.Свойство("Вычислить")
			И	(	Найти(СбисПоле.Вычислить,"'") = 1
				Или	Найти(СбисПоле.Вычислить,"{") = 1
				Или	Найти(СбисПоле.Вычислить,"^") = 1) Тогда
			//UAA обновлено условие. Если значение вычисляется на сервере, то должно быть ВычислитьНаСервере. Проверка по 1 символу
			РезультатРасчета = РассчитатьЗначение(СбисПоле.Вычислить, АргументыРассчитать, Кэш);
			ЗаполнитьЗначениеРеквизита(РезультатРасчета, СбисПоле.Значение, АргументыРассчитать.СтрТабл, АргументыРассчитать.Переменные);
			СбисПоле.Вставить("РассчитанноеЗначение", РезультатРасчета);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

//Вынесен общий код и проверки в отдельную функцию
&НаСервереБезКонтекста
Процедура СбисВычислитьПолеНаСервере(Знач СбисПоле, Знач АргументыРассчитать, ДанныеЗаполнить)
	Перем лПараметрВычислить, РезультатРасчета, ПолеЗначение;
	Если	Не	СбисПоле.Свойство("Значение", ПолеЗначение) Тогда
		Если ЭтоСложныйУзел_Сервер(СбисПоле) Тогда//Это сложный узел, требующий рекурсивного обсчёта
			ОбработатьСложныйУзел_Сервер(СбисПоле, АргументыРассчитать.СтрокаФайла, АргументыРассчитать.Документ, АргументыРассчитать);
		КонецЕсли;
	ИначеЕсли	СбисПоле.Свойство("РассчитанноеЗначение", РезультатРасчета) Тогда
		Если	АргументыРассчитать.Свойство("ЗаполнитьРасчитанноеЗначение")
			И	АргументыРассчитать.ЗаполнитьРасчитанноеЗначение Тогда
			ЗаполнитьЗначениеРеквизитаНаСервере(РезультатРасчета, ПолеЗначение, ДанныеЗаполнить, АргументыРассчитать);
		КонецЕсли;
	ИначеЕсли 	ЕстьПараметрВычислитьНаСервере(СбисПоле, лПараметрВычислить) Тогда
		РезультатРасчета = РассчитатьЗначениеНаСервере(лПараметрВычислить, АргументыРассчитать);
		Если СбисПоле.Свойство("Отбор") Тогда
			РезультатРасчета = СбисВычислитьОтборНаСервере(СбисПоле, РезультатРасчета, АргументыРассчитать);
		КонецЕсли;
		ЗаполнитьЗначениеРеквизитаНаСервере(РезультатРасчета, ПолеЗначение, ДанныеЗаполнить, АргументыРассчитать);
		СбисПоле.Вставить("РассчитанноеЗначение", РезультатРасчета);
	КонецЕсли;
КонецПроцедуры

&НаСервереБезКонтекста
Функция СбисВычислитьОтборНаСервере(СбисПоле, РасчитанноеЗначение, АргументыРассчитать)
	Перем СбисВыбрать, ПараметрПроверить;
	Результат = РасчитанноеЗначение;
	Если Не ЗначениеЗаполнено(РасчитанноеЗначение) Тогда
		Возврат Результат;
	КонецЕсли;
	СписокОтборов = Новый Структура;
	Для Каждого ЭлементОтбора Из СбисПоле.Отбор Цикл
		СписокОтборов.Вставить(ЭлементОтбора.Ключ, РассчитатьЗначениеНаСервере(ЭлементОтбора.Значение, АргументыРассчитать));
	КонецЦикла;
	Если Не СбисПоле.Свойство("Выбрать", СбисВыбрать) Тогда
		СбисВыбрать = "все";
	Иначе
		СбисВыбрать = НРег(СбисВыбрать);
		Если Не СбисВыбрать = "все" Тогда
			Попытка
				СбисВыбрать = Число(СбисВыбрать);
			Исключение
				Сообщить("Не верно указан размер выборки. Допустимые значения: число; ""Все""");
				Возврат Результат;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	Если ТипЗнч(РасчитанноеЗначение) = Тип("ТаблицаЗначений") Тогда
		РезультатОтбора = РасчитанноеЗначение.НайтиСтроки(СписокОтборов);
		Результат = Новый Массив;
		Если	СбисВыбрать = "все" 
			Или СбисВыбрать >= РезультатОтбора.Количество() Тогда
			Результат = РезультатОтбора;
		ИначеЕсли РезультатОтбора.Количество() Тогда
			Если СбисВыбрать = 1 Тогда
				Возврат РезультатОтбора[0];
			КонецЕсли;
			Для ЧислоСтрокВыборки = 1 По СбисВыбрать Цикл
				Результат.Добавить(РезультатОтбора[ЧислоСтрокВыборки-1]);
			КонецЦикла;
		КонецЕсли;
	ИначеЕсли ТипЗнч(РасчитанноеЗначение) = Тип("Массив") Тогда
		Результат = Новый Массив;
		Для Каждого СтрокаРасчитанноеЗначение Из РасчитанноеЗначение Цикл
			ДобавитьСтроку = Истина;
			Для Каждого КлючИЗначениеОтбор Из СписокОтборов Цикл
				Если	Не СтрокаРасчитанноеЗначение.Свойство(КлючИЗначениеОтбор.Ключ, ПараметрПроверить)
					Или	Не ПараметрПроверить = КлючИЗначениеОтбор.Значение Тогда
					ДобавитьСтроку = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ДобавитьСтроку Тогда
				Результат.Добавить(СтрокаРасчитанноеЗначение);
				Если СбисВыбрать = 1 Тогда
					Возврат СтрокаРасчитанноеЗначение;
				ИначеЕсли Не СбисВыбрать = "все" Тогда
					Если Результат.Количество() = СбисВыбрать Тогда
						Прервать;
					КонецЕсли;
				КонецЕсли;				
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Результат) Тогда
		Результат = "";
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

//Процедура проставляет связи документов, загруженных из одного пакета	
Процедура ЗаполнитьСвязанныеДокументы(ТипДок, ИмяРеквизита, знач РазделИни, ДокОбъект, МассивОснований)
	Если Метаданные.Документы[ТипДок].Реквизиты.Найти(ИмяРеквизита)<>Неопределено Тогда
		ТипыОснований = Новый ОписаниеТипов(РазделИни.Основание.Тип);
		Для Каждого Основание Из МассивОснований Цикл
			Если ТипыОснований.СодержитТип(ТипЗнч(Основание)) Тогда	
				ДокОбъект.Вставить(ИмяРеквизита, Основание);
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли Метаданные.Документы[ТипДок].ТабличныеЧасти.Найти(ИмяРеквизита)<>Неопределено Тогда
		ИмяРеквизитаВТЧ = Сред(РазделИни.Основание_Документ.Значение, Найти(РазделИни.Основание_Документ.Значение,".")+1);
		ТипыОснований = Новый ОписаниеТипов(РазделИни.Основание_Документ.Тип);
		Для Каждого Основание Из МассивОснований Цикл
			Если ТипыОснований.СодержитТип(ТипЗнч(Основание)) Тогда	
				Если Не ДокОбъект.Свойство(ИмяРеквизита) Тогда
					ДокОбъект.Вставить(ИмяРеквизита, Новый массив);
				КонецЕсли;
				ДокОбъект[ИмяРеквизита].Добавить(Новый Структура(ИмяРеквизитаВТЧ, Основание));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Функция ЗаполнитьДанныеДокумента1С(Кэш, ини, СтруктураФайла, МассивОснований,СоставПакета, Вложение, Документ1С = Неопределено, ДополнительныеДанные=Неопределено) Экспорт
	// Функция заполняет структуру документа 1С, создает документ и заполняет его из структуры	
	ЗаполнитьДетализацию= Ложь;
	Отказ				= Ложь;
	Если Не ДополнительныеДанные = Неопределено Тогда
		Если Не ДополнительныеДанные.Свойство("ЗаполнитьДетализацию", ЗаполнитьДетализацию) Тогда
			ЗаполнитьДетализацию = Ложь;
		КонецЕсли;
		ДополнительныеДанные.Свойство("Отказ", Отказ);
	КонецЕсли;
	
	СтруктураДокОбъект = Новый Структура; // Структура с названиями полей, как у создаваемого документа 1С
	Если Документ1С<>Неопределено Тогда
		МестныйКэш.ОбщиеФункции.ЗаполнитьСтруктуруИзШапкиДокумента1С(СтруктураДокОбъект,Документ1С);
	КонецЕсли;
	// Вносим ручные изменения перед расчетом, чтобы правильно рассчитались зависимые от них реквизиты (например, валюта из договора)
	ЗаполнитьРучныеИзмененияДокумента1С(Кэш, Вложение, СтруктураДокОбъект);
	ЗаполнитьДаннымиСтруктурыФайлаСтруктуруДокумента(Кэш, СтруктураФайла, ини, СтруктураДокОбъект, МассивОснований,СоставПакета, Вложение);
	// И после расчета заменяем значения, на выбранные вручную
	ЗаполнитьРучныеИзмененияДокумента1С(Кэш, Вложение, СтруктураДокОбъект);	
	Вложение.Вставить("СтруктураДокумента1С", СтруктураДокОбъект);
	//По 1176019292	
	ТипОбъекта = СтрПолучитьСтроку(СтрЗаменить(Кэш.ОбщиеФункции.РассчитатьЗначение("Документ", Ини), ".", Символы.ПС), 1);
	сбисДополнительныеПараметры = Новый Структура("ОбъектПерезаполнитьСсылка, ТипОбъекта, ПодТипОбъекта", Документ1С, ТипОбъекта, ТипДокумента);
	РезультатЗагрузки = СоздатьОбъектИзСтруктуры(СтруктураДокОбъект, сбисДополнительныеПараметры, Отказ);
	РезультатЗагрузки.Вставить("СтруктураДокумента1С", СтруктураДокОбъект);//Для дальнейшей обработки и чтобы не тянуть с сервера на клиента добавляем в результат структуру документа 1С тут.
	Если ЗаполнитьДетализацию Тогда
		РезультатЗагрузки.Вставить("Ошибки", Отказ);
		Кэш.ОбщиеФункции.РезультатДействия_ДобавитьВРасшифровку(Кэш, "ЗагрузкаДокумента", ДополнительныеДанные.СтрокаДетализации, РезультатЗагрузки);
		ДополнительныеДанные.Отказ = Отказ;
	Иначе                      
		Сообщить(РезультатЗагрузки.Сообщение);
	КонецЕсли;
	фрм = Кэш.ГлавноеОкно.сбисНайтиФормуФункции("ДопРасчетыПриЗагрузке","Документ_"+ТипДокумента,"Документ_Шаблон",МестныйКэш);			
	Если фрм<>Ложь Тогда
		Попытка
			фрм.ДопРасчетыПриЗагрузке(РезультатЗагрузки.Ссылка, Новый Структура("СтруктураФайла, СоставПакета, Кэш",СтруктураФайла,СоставПакета,МестныйКэш));
		Исключение
			фрм.ДопРасчетыПриЗагрузке(РезультатЗагрузки.Ссылка);//Вставлено исключение для совместимости со старой версией
		КонецПопытки
	КонецЕсли;
		
	Возврат РезультатЗагрузки.Ссылка;
КонецФункции

&НаКлиенте
Функция ЗаполнитьРучныеИзмененияДокумента1С(Кэш, Вложение, СтруктураДокОбъект) Экспорт
	// Если реквизиты были изменены вручную на форме просмотра (контрагент, договор, дата), то заменяем их в сформированной структуре документа
	Если Вложение.Свойство("РучноеИзменение") И Вложение.РучноеИзменение = Истина Тогда
		Попытка
			Если Вложение.СтруктураИниФайла.Свойство("Договор") и Вложение.СтруктураИниФайла.Договор.Свойство("Значение") и Вложение.Свойство("Договор1С") Тогда
				ИмяРеквизита = Сред(Вложение.СтруктураИниФайла.Договор.Значение, Найти(Вложение.СтруктураИниФайла.Договор.Значение,".")+1);
				СтруктураДокОбъект.Вставить(ИмяРеквизита, Вложение.Договор1С);
			КонецЕсли;
			Если Вложение.СтруктураИниФайла.Свойство("Документ_Дата") и Вложение.СтруктураИниФайла.Документ_Дата.Свойство("Значение") и Вложение.Свойство("Дата1С") Тогда
				ИмяРеквизита = Сред(Вложение.СтруктураИниФайла.Документ_Дата.Значение, Найти(Вложение.СтруктураИниФайла.Документ_Дата.Значение,".")+1);
				СтруктураДокОбъект.Вставить(ИмяРеквизита, Вложение.Дата1С);
			КонецЕсли;
			Если Вложение.СтруктураИниФайла.Свойство("Контрагент_Роль") и Вложение.СтруктураИниФайла.Контрагент_Роль.Свойство("Значение") и Вложение.Свойство("Контрагент1С") Тогда
				КонтрагентРоль=МестныйКэш.ОбщиеФункции.РассчитатьЗначение("Контрагент_Роль", Вложение.СтруктураИниФайла, МестныйКэш);
				ИмяРеквизита = Сред(Вложение.СтруктураИниФайла.мСторона[КонтрагентРоль].Сторона.Значение, Найти(Вложение.СтруктураИниФайла.мСторона[КонтрагентРоль].Сторона.Значение,".")+1);
				СтруктураДокОбъект.Вставить(ИмяРеквизита, Вложение.Контрагент1С);
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
КонецФункции

//Функция заполняет реквизит в структуре документа 1С значением из файла
&НаКлиенте
Функция ЗаполнитьЗначениеРеквизитаИзФайла(ЭлементИни, СтруктураФайла, Контекст, МестныйКэш) Экспорт
	ЗнПер = ЭлементИни.Значение;
	ЗначениеРеквизита = МестныйКэш.ОбщиеФункции.РассчитатьЗначениеИзСтруктуры(ЭлементИни.Данные, СтруктураФайла);
	
	Если ЭлементИни.Свойство("Тип") Тогда//AU вынесена проверка наличия атрибута типа для всех значений для корректного обсчета формул.
		Если ЭлементИни.Тип="Дата" и ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
			ЗначениеРеквизита = Дата(Сред(ЗначениеРеквизита,7,4),Сред(ЗначениеРеквизита,4,2),Лев(ЗначениеРеквизита,2));
		КонецЕсли;
	КонецЕсли;
	Если ЭлементИни.Свойство("Отбор") И ЭлементИни.Отбор.Свойство("НомерСтроки") И ТипЗнч(ЗначениеРеквизита) = Тип("Массив") Тогда
		Попытка
			НомерСтроки = Число(ЭлементИни.Отбор.НомерСтроки);
			ЗначениеРеквизита = ЗначениеРеквизита[НомерСтроки];
			ЭлементИни.Значение = ЗначениеРеквизита;
		Исключение
		КонецПопытки;
	КонецЕсли;
	Если Найти(ЗнПер,"[")=1 Тогда  // ссылка на реквизит
		ИмяРеквизита=сред(ЗнПер,Найти(ЗнПер,".")+1);
		Контекст.Вставить(ИмяРеквизита, ЗначениеРеквизита);
	Иначе // если нет ссылка на реквизит, кладем значение в саму структуру ини, чтобы потом это значение можно было использовать при расчете других 
		ЭлементИни.Значение = ЗначениеРеквизита;
	КонецЕсли;
	Возврат ЗначениеРеквизита;
КонецФункции

//Функция заполняет реквизит в структуре документа 1С значением	
&НаКлиенте
Функция ЗаполнитьЗначениеРеквизита(ЗначениеРеквизита, ПутьРеквизита, Контекст, Переменные) Экспорт
	Если Найти(ПутьРеквизита,"[")=1 Тогда  // ссылка на реквизит
		ИмяРеквизита=сред(ПутьРеквизита,Найти(ПутьРеквизита,".")+1);
		Контекст.Вставить(ИмяРеквизита, ЗначениеРеквизита);
	ИначеЕсли Найти(ПутьРеквизита,"'") = 0 и Найти(ПутьРеквизита,".") = 0 Тогда
		Переменные.Вставить(СтрЗаменить(ПутьРеквизита, ".", "_"), ЗначениеРеквизита);
	КонецЕсли;
КонецФункции

//Функция заполняет реквизит в структуре документа 1С значением	
&НаСервереБезКонтекста
Процедура ЗаполнитьЗначениеРеквизитаНаСервере(ЗначениеРеквизита, ПутьРеквизита, Контекст, ДопПараметры) Экспорт
	Если		Найти(ПутьРеквизита, "[") = 1 Тогда
		//В ДокОбъект заполняем только простые типы.
		Если	ТипЗнч(ЗначениеРеквизита) = Тип("Структура")
			Или	ТипЗнч(ЗначениеРеквизита) = Тип("Массив") Тогда
			Возврат;
		КонецЕсли;
		СтрПутьРеквизита = СтрЗаменить(СтрЗаменить(СтрЗаменить(ПутьРеквизита, "[", ""), "]", ""), ".", Символы.ПС);
		Если	Не	ДопПараметры.Свойство("ИмяТЧ")
			Или		ДопПараметры.ИмяТЧ = СтрПолучитьСтроку(СтрПутьРеквизита, 1) Тогда
			Контекст.Вставить(СтрПолучитьСтроку(СтрПутьРеквизита, 2), ЗначениеРеквизита);
		КонецЕсли;
	ИначеЕсли	Найти(ПутьРеквизита, "'") = 0 Тогда
		ДопПараметры.Переменные.Вставить(СтрЗаменить(ПутьРеквизита, ".", "_"), ЗначениеРеквизита);
	КонецЕсли;
КонецПроцедуры

//Возвращает имя реквизита из значения в файле настроек	
Функция СообщитьИмяРеквизита(ЗначениеРеквизита)Экспорт
	Возврат Сред(ЗначениеРеквизита,Найти(ЗначениеРеквизита,".")+1,СтрДлина(ЗначениеРеквизита)-Найти(ЗначениеРеквизита,"."));	
КонецФункции

&НаСервереБезКонтекста
функция РазбитьСтрокуВМассив(знач Строка, Разделитель) Экспорт
	// Функция разбивает строку по определенному разделителю и формирует массив из получившихся элементов		
	МассивЭлементов = Новый Массив();
	Если Строка<>"" Тогда
	ЕстьРазделитель = Истина;
	Пока ЕстьРазделитель И Строка<>"" И Разделитель<>"" Цикл
		Если Найти(Строка,Разделитель)=0 Тогда
			Прервать;
		КонецЕсли;
		Элемент = Сред(Строка,1,Найти(Строка,Разделитель)-1);
		МассивЭлементов.Добавить(Элемент);
		Строка = Сред(Строка,Найти(Строка,Разделитель)+1);
	КонецЦикла;
	МассивЭлементов.Добавить(Строка);
	КонецЕсли;
	Возврат МассивЭлементов;
КонецФункции

&НаКлиенте
Функция РассчитатьЗначение(Параметр,Контекст,Кэш) Экспорт //Контекст{ини,Документ,СтрТабл}
	// Функция рассчитывает	значение параметра из файла настроек
	// Для функций и строк возвращает результат, для других значений вызывает расчет на сервере
	Если Найти(Параметр,"[")>0 или Найти(Параметр,"'")>0 или Найти(Параметр,"{")>0 или Найти(Параметр,"^") Тогда  // в случае, если в качестве параметра функции используется, не имя, а значение параметра
		ЗнПер=СокрЛП(Параметр);
		ИмяПеременнойВПараметре = Ложь;
	Иначе
		ИмяПеременнойВПараметре = Истина;
		Попытка
			ЗнПер=Контекст.Ини[Параметр].Значение;
		Исключение
			возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	Если Найти(ЗнПер,"{")=1 Тогда // функция
		ИмяФункции=сред(ЗнПер,2,Найти(ЗнПер,"(")-2);
		Документ = Неопределено;
		Контекст.Свойство("Документ", Документ);
		СтрТабл = Неопределено;
		Контекст.Свойство("СтрТабл", СтрТабл);
		Переменные = Неопределено;
		Контекст.Свойство("Переменные", Переменные);
		Попытка
			Если Найти(ИмяФункции, ".") Тогда
				Результат=вычислить(Сред(ЗнПер, 2, СтрДлина(ЗнПер)-2));
			Иначе
				фрм = Кэш.ГлавноеОкно.сбисНайтиФормуФункции(ИмяФункции,"РаботаСДокументами1С","", Кэш);
				Результат=вычислить("фрм."+ИмяФункции+"(Контекст)");
			КонецЕсли;	
		Исключение
			Ошибка = ОписаниеОшибки();
			сообщить(Ошибка+ "(ошибка при вычислении функции """+Сред(ЗнПер, 2, СтрДлина(ЗнПер)-2)+""")");
		КонецПопытки;	
		возврат Результат;
	ИначеЕсли Найти(ЗнПер,"'")=1 Тогда	 // строка
		Если ЗнПер="'Истина'" Тогда
			Возврат Истина;
		ИначеЕсли ЗнПер="'Ложь'" Тогда
			Возврат Ложь;
		Иначе
			Возврат Сред(ЗнПер,2,СтрДлина(ЗнПер)-2);
		КонецЕсли;
	ИначеЕсли Найти(ЗнПер,"^")=1 Тогда  // формула, которую необходимо вычислить
		ЗнПер=сбисВычислитьФормулу(ЗнПер,Параметр,Контекст,Кэш);
		Возврат ЗнПер;					
	Иначе
		возврат РассчитатьЗначениеНаСервере(Параметр,Контекст);
	КонецЕсли	
КонецФункции

&НаКлиенте
Функция РассчитатьЗначениеПараметра(Параметр,Контекст,Кэш) Экспорт //Контекст{ини,Документ,СтрТабл}
	// Функция рассчитывает	значение параметра из файла настроек
	// Для функций и строк возвращает результат, для других значений вызывает расчет на сервере
	ЗначениеРеквизита = Неопределено;
	Если Найти(Параметр,"[")>0 или Найти(Параметр,"'")>0 или Найти(Параметр,"{")>0 Тогда  // в случае, если в качестве параметра функции используется, не имя, а значение параметра
		СтрПараметр = СокрЛП(Параметр);
		ЗначениеРеквизита = РассчитатьЗначение(СтрПараметр,Контекст,Кэш);
	Иначе
		Попытка
			СтрПараметр = Контекст.Ини[Параметр];
			Если СтрПараметр.Свойство("РассчитанноеЗначение", ЗначениеРеквизита) Тогда
				//UAA Значение уже посчитано. Возвращаем его 1178200619
			ИначеЕсли СтрПараметр.Свойство("Данные") Тогда
				ЗначениеРеквизита = ЗаполнитьЗначениеРеквизитаИзФайла(СтрПараметр, Контекст.СтруктураФайла, Новый Структура, Кэш);						
			ИначеЕсли СтрПараметр.Свойство("Вычислить") Тогда
				ЗначениеРеквизита = РассчитатьЗначение(СтрПараметр.Вычислить,Контекст,Кэш);
			КонецЕсли;
		Исключение
			ЗначениеРеквизита = Неопределено;
		КонецПопытки;
	КонецЕсли;
	Возврат ЗначениеРеквизита;
КонецФункции

&НаКлиенте
Функция СбисВычислитьФормулу(ЗнПер, ПараметрИни, Контекст, Кэш)
	Попытка
		ВычисляемаяСтрока = СокрЛП(Сред(ЗнПер, 2));
		ПозСкобки = Найти(ВычисляемаяСтрока, "(");
		ИмяФормулы = нрег(СокрЛП(Лев(ВычисляемаяСтрока, ПозСкобки-1)));
		СтрокаПараметров = Сред(ВычисляемаяСтрока,ПозСкобки+1, СтрДлина(ВычисляемаяСтрока)-ПозСкобки-1);
		МассивПараметров = Кэш.ОбщиеФункции.РазбитьСтрокуВМассивНаКлиенте(СтрокаПараметров, ",");
		ТекущееПолеИни = Новый Структура;
		Если ТипЗнч(ПараметрИни)=Тип("Структура") Тогда
			ТекущееПолеИни = ПараметрИни;
		ИначеЕсли Контекст.Свойство("ТекущееПолеИни") Тогда
			ТекущееПолеИни = Контекст.ТекущееПолеИни;
		КонецЕсли;
		Если ИмяФормулы = ">" Тогда
			Если МассивПараметров.Количество()<>4 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				сч = сч+1;
			КонецЦикла;
			Если МассивПараметров[0]>МассивПараметров[1] Тогда
				Возврат МассивПараметров[2];
			Иначе
				Возврат МассивПараметров[3];
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "<" Тогда
			Если МассивПараметров.Количество()<>4 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				сч = сч+1;
			КонецЦикла;
			Если МассивПараметров[0]<МассивПараметров[1] Тогда
				Возврат МассивПараметров[2];
			Иначе
				Возврат МассивПараметров[3];
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "=" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если НЕ (КолПараметров=3 или КолПараметров=4) Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				сч = сч+1;
			КонецЦикла;
			Если КолПараметров = 3 Тогда
				Если ЗначениеЗаполнено(МассивПараметров[0]) Тогда
					Возврат МассивПараметров[1];
				Иначе
					Возврат МассивПараметров[2];
				КонецЕсли;
			Иначе
				Если МассивПараметров[0]=МассивПараметров[1] Тогда
					Возврат МассивПараметров[2];
				Иначе
					Возврат МассивПараметров[3];
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "!=" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если НЕ (КолПараметров=3 или КолПараметров=4) Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				сч = сч+1;
			КонецЦикла;
			Если КолПараметров = 3 Тогда
				Если НЕ ЗначениеЗаполнено(МассивПараметров[0]) Тогда
					Возврат МассивПараметров[1];
				Иначе
					Возврат МассивПараметров[2];
				КонецЕсли;
			Иначе
				Если МассивПараметров[0]<>МассивПараметров[1] Тогда
					Возврат МассивПараметров[2];
				Иначе
					Возврат МассивПараметров[3];
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "+" Тогда
			Если ТекущееПолеИни.Свойство("Тип") и ТекущееПолеИни.Тип = "Число" Тогда
					Результат = 0;
			Иначе
				Результат = "";
			КонецЕсли;
			Для Каждого Элемент Из МассивПараметров Цикл
				Элемент = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				Если ТекущееПолеИни.Свойство("Тип") и ТекущееПолеИни.Тип = "Число" Тогда
					Результат = Результат + Число(Элемент);
				Иначе
					Результат = Результат + Элемент;
				КонецЕсли;	
			КонецЦикла;
			Если ТекущееПолеИни.Свойство("Формат") Тогда
				Результат = Формат(Результат,ТекущееПолеИни.Формат);
			КонецЕсли;
			Возврат Результат;
		ИначеЕсли ИмяФормулы = "*" Тогда
			Результат = 1;
			Для Каждого Элемент Из МассивПараметров Цикл
				Элемент = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				Результат = Результат * Число(Элемент);
			КонецЦикла;
			Если ТекущееПолеИни.Свойство("Формат") Тогда
				Результат = Формат(Результат,ТекущееПолеИни.Формат);
			КонецЕсли;
			Возврат Результат;
		ИначеЕсли ИмяФормулы = "сред" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если НЕ (КолПараметров=2 или КолПараметров=3) Тогда
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				сч = сч+1;
			КонецЦикла;
			Если КолПараметров=2 Тогда
				Возврат Сред(МассивПараметров[0],МассивПараметров[1]);
			Иначе
				Возврат Сред(МассивПараметров[0],МассивПараметров[1],МассивПараметров[2]);	
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "найти" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если КолПараметров<>2 Тогда
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				сч = сч+1;
			КонецЦикла;
			Возврат Найти(МассивПараметров[0],МассивПараметров[1]);	
		ИначеЕсли ИмяФормулы = "или" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<3 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			МассивПараметров[КолПараметров-1] = РассчитатьЗначениеПараметра(МассивПараметров[КолПараметров-1], Контекст, Кэш);
			МассивПараметров[КолПараметров-2] = РассчитатьЗначениеПараметра(МассивПараметров[КолПараметров-2], Контекст, Кэш);
			Для сч = 0 По КолПараметров-3 Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(МассивПараметров[сч], Контекст, Кэш);
				Если МассивПараметров[сч] = Истина Тогда
					Возврат МассивПараметров[КолПараметров-2];
				КонецЕсли;
			КонецЦикла;
			Возврат МассивПараметров[КолПараметров-1];
	    ИначеЕсли ИмяФормулы = "и" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<3 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			МассивПараметров[КолПараметров-1] = РассчитатьЗначениеПараметра(МассивПараметров[КолПараметров-1], Контекст, Кэш);
			МассивПараметров[КолПараметров-2] = РассчитатьЗначениеПараметра(МассивПараметров[КолПараметров-2], Контекст, Кэш);
			Для сч = 0 По КолПараметров-3 Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(МассивПараметров[сч], Контекст, Кэш);
				Если МассивПараметров[сч] = Ложь Тогда
					Возврат МассивПараметров[КолПараметров-1];
				КонецЕсли;
			КонецЦикла;
			Возврат МассивПараметров[КолПараметров-2];
		ИначеЕсли ИмяФормулы = "окрбольше" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<>1 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			МассивПараметров[0] = РассчитатьЗначениеПараметра(МассивПараметров[0], Контекст, Кэш);
			Если Цел(МассивПараметров[0]) = МассивПараметров[0] Тогда
				Возврат МассивПараметров[0];
			Иначе
				Возврат Цел(МассивПараметров[0])+1;
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "окр" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<2 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеПараметра(Элемент, Контекст, Кэш);
				сч = сч+1;
			КонецЦикла;
			Если МассивПараметров.Количество() = 2 Тогда
				Возврат Окр(Число(МассивПараметров[0]), Число(МассивПараметров[1]));
			Иначе
				Возврат Окр(Число(МассивПараметров[0]), Число(МассивПараметров[1]), РежимОкругления.Окр15как10);
			КонецЕсли;
		КонецЕсли;
	Исключение
		Ошибка = ОписаниеОшибки();
		Возврат Неопределено
	КонецПопытки
	
КонецФункции

&НаСервереБезКонтекста
Функция СбисВычислитьФормулуНаСервере(ЗнПер, ПараметрИни, Контекст)
	
	Попытка
		ВычисляемаяСтрока = СокрЛП(Сред(ЗнПер, 2));
		ПозСкобки = Найти(ВычисляемаяСтрока, "(");
		ИмяФормулы = нрег(СокрЛП(Лев(ВычисляемаяСтрока, ПозСкобки-1)));
		СтрокаПараметров = Сред(ВычисляемаяСтрока,ПозСкобки+1, СтрДлина(ВычисляемаяСтрока)-ПозСкобки-1);
		МассивПараметров = РазбитьСтрокуВМассив(СтрокаПараметров, ",");
		ТекущееПолеИни = Новый Структура;
		Если ТипЗнч(ПараметрИни)=Тип("Структура") Тогда
			ТекущееПолеИни = ПараметрИни;
		ИначеЕсли Контекст.Свойство("ТекущееПолеИни") Тогда
			ТекущееПолеИни = Контекст.ТекущееПолеИни;
		КонецЕсли;
		Если ИмяФормулы = ">" Тогда
			Если МассивПараметров.Количество()<>4 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				сч = сч+1;
			КонецЦикла;
			Если МассивПараметров[0]>МассивПараметров[1] Тогда
				Возврат МассивПараметров[2];
			Иначе
				Возврат МассивПараметров[3];
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "<" Тогда
			Если МассивПараметров.Количество()<>4 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				сч = сч+1;
			КонецЦикла;
			Если МассивПараметров[0]<МассивПараметров[1] Тогда
				Возврат МассивПараметров[2];
			Иначе
				Возврат МассивПараметров[3];
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "=" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если НЕ (КолПараметров=3 или КолПараметров=4) Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				сч = сч+1;
			КонецЦикла;
			Если КолПараметров = 3 Тогда
				Если ЗначениеЗаполнено(МассивПараметров[0]) Тогда
					Возврат МассивПараметров[1];
				Иначе
					Возврат МассивПараметров[2];
				КонецЕсли;
			Иначе
				Если МассивПараметров[0]=МассивПараметров[1] Тогда
					Возврат МассивПараметров[2];
				Иначе
					Возврат МассивПараметров[3];
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "!=" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если НЕ (КолПараметров=3 или КолПараметров=4) Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				сч = сч+1;
			КонецЦикла;
			Если КолПараметров = 3 Тогда
				Если НЕ ЗначениеЗаполнено(МассивПараметров[0]) Тогда
					Возврат МассивПараметров[1];
				Иначе
					Возврат МассивПараметров[2];
				КонецЕсли;
			Иначе
				Если МассивПараметров[0]<>МассивПараметров[1] Тогда
					Возврат МассивПараметров[2];
				Иначе
					Возврат МассивПараметров[3];
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "+" Тогда
			Если ТекущееПолеИни.Свойство("Тип") и ТекущееПолеИни.Тип = "Число" Тогда
				Результат = 0;
			Иначе
				Результат = "";
			КонецЕсли;
			Для Каждого Элемент Из МассивПараметров Цикл
				Элемент = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				Если ТекущееПолеИни.Свойство("Тип") и ТекущееПолеИни.Тип = "Число" Тогда
					Результат = Результат + Число(Элемент);
				Иначе
					Результат = Результат + Элемент;
				КонецЕсли;	
			КонецЦикла;
			Если ТекущееПолеИни.Свойство("Формат") Тогда
				Результат = Формат(Результат,ТекущееПолеИни.Формат);
			КонецЕсли;
			Возврат Результат;
		ИначеЕсли ИмяФормулы = "*" Тогда
			Результат = 1;
			Для Каждого Элемент Из МассивПараметров Цикл
				Элемент = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				Результат = Результат * Число(Элемент);
			КонецЦикла;
			Если ТекущееПолеИни.Свойство("Формат") Тогда
				Результат = Формат(Результат,ТекущееПолеИни.Формат);
			КонецЕсли;
			Возврат Результат;
		ИначеЕсли ИмяФормулы = "сред" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если НЕ (КолПараметров=2 или КолПараметров=3) Тогда
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				сч = сч+1;
			КонецЦикла;
			Если КолПараметров=2 Тогда
				Возврат Сред(МассивПараметров[0],МассивПараметров[1]);
			Иначе
				Возврат Сред(МассивПараметров[0],МассивПараметров[1],МассивПараметров[2]);	
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "найти" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если КолПараметров<>2 Тогда
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				сч = сч+1;
			КонецЦикла;
			Возврат Найти(МассивПараметров[0],МассивПараметров[1]);	
		ИначеЕсли ИмяФормулы = "или" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<3 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			МассивПараметров[КолПараметров-1] = РассчитатьЗначениеНаСервере(МассивПараметров[КолПараметров-1], Контекст);
			МассивПараметров[КолПараметров-2] = РассчитатьЗначениеНаСервере(МассивПараметров[КолПараметров-2], Контекст);
			Для сч = 0 По КолПараметров-3 Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(МассивПараметров[сч], Контекст);
				Если МассивПараметров[сч] = Истина Тогда
					Возврат МассивПараметров[КолПараметров-2];
				КонецЕсли;
			КонецЦикла;
			Возврат МассивПараметров[КолПараметров-1];
		ИначеЕсли ИмяФормулы = "и" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<3 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			МассивПараметров[КолПараметров-1] = РассчитатьЗначениеНаСервере(МассивПараметров[КолПараметров-1], Контекст);
			МассивПараметров[КолПараметров-2] = РассчитатьЗначениеНаСервере(МассивПараметров[КолПараметров-2], Контекст);
			Для сч = 0 По КолПараметров-3 Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(МассивПараметров[сч], Контекст);
				Если МассивПараметров[сч] = Ложь Тогда
					Возврат МассивПараметров[КолПараметров-1];
				КонецЕсли;
			КонецЦикла;
			Возврат МассивПараметров[КолПараметров-2];
		ИначеЕсли ИмяФормулы = "окрбольше" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<>1 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			МассивПараметров[0] = РассчитатьЗначениеНаСервере(МассивПараметров[0], Контекст);
			Если Цел(МассивПараметров[0]) = МассивПараметров[0] Тогда
				Возврат МассивПараметров[0];
			Иначе
				Возврат Цел(МассивПараметров[0])+1;
			КонецЕсли;
		ИначеЕсли ИмяФормулы = "окр" Тогда
			КолПараметров = МассивПараметров.Количество();
			Если МассивПараметров.Количество()<2 Тогда   // неправильно написана формула
				Возврат Неопределено;
			КонецЕсли;
			сч = 0;
			Для Каждого Элемент Из МассивПараметров Цикл
				МассивПараметров[сч] = РассчитатьЗначениеНаСервере(Элемент, Контекст);
				сч = сч+1;
			КонецЦикла;
			Если МассивПараметров.Количество() = 2 Тогда
				Возврат Окр(Число(МассивПараметров[0]), Число(МассивПараметров[1]));
			Иначе
				Возврат Окр(Число(МассивПараметров[0]), Число(МассивПараметров[1]), РежимОкругления.Окр15как10);
			КонецЕсли;
		КонецЕсли;
	Исключение
		Ошибка = ОписаниеОшибки();
		Возврат Неопределено
	КонецПопытки
	
КонецФункции

&НаСервереБезКонтекста
Функция РассчитатьЗначениеНаСервере(Параметр, Контекст) Экспорт
	// Функция рассчитывает	значение параметра из файла настроек на сервере	
	ПервыйСимвол = Лев(СокрЛП(Параметр),1);
	Если ПервыйСимвол="[" или ПервыйСимвол="'" или ПервыйСимвол="{" или ПервыйСимвол="^" Тогда  // в случае, если в качестве параметра функции используется, не имя, а значение параметра
		ЗнПер=Параметр;
		ИмяПеременнойВПараметре = Ложь;
	Иначе
		ИмяПеременнойВПараметре = Истина;
		Попытка
			ПараметрИни = Неопределено;
			ЗнПер = Неопределено;
			Если		Не	Контекст.Ини.Свойство(Параметр, ПараметрИни) Тогда
				Возврат Неопределено;
			ИначеЕсли	ПараметрИни.Свойство("РассчитанноеЗначение", ЗнПер) Тогда
				Возврат ЗнПер;
			ИначеЕсли	ПараметрИни.Свойство("ВычислитьНаСервере", ЗнПер)
					И	ЗначениеЗаполнено(ЗнПер) Тогда
				//Вычислить на сервере
			ИначеЕсли	Не	ПараметрИни.Свойство("Значение", ЗнПер) Тогда
				Возврат Неопределено;
				//	//Берём сам узел как результат
				//	Возврат ПараметрИни;
			КонецЕсли;
		Исключение
			возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	ПозТочки = Найти(ЗнПер, ".");
	ПервыйСимвол = Лев(ЗнПер,1);
	Если ПервыйСимвол="{" Тогда   // функции из глобальных серверных модулей 1С
		Документ = Неопределено;
		Контекст.Свойство("Документ", Документ);
		СтрТабл = Неопределено;
		Контекст.Свойство("СтрТабл", СтрТабл);
		Переменные = Неопределено;
		Контекст.Свойство("Переменные", Переменные);
		Попытка
			Результат = вычислить(Сред(ЗнПер, 2, СтрДлина(ЗнПер)-2));
		Исключение
			Ошибка = ОписаниеОшибки();
			сообщить(Ошибка+ "(ошибка при вычислении функции """+Сред(ЗнПер, 2, СтрДлина(ЗнПер)-2)+""")");
		КонецПопытки;
		Возврат Результат;
	ИначеЕсли ПервыйСимвол="[" Тогда  // ссылка на объект (другую переменную)
		СтрОбъекта=Сред(ЗнПер,2,Найти(ЗнПер,"]")-2);
		Объект1С=РассчитатьЗначениеНаСервере(СтрОбъекта,Контекст);
		Если Найти(ЗнПер,".")>0 Тогда
			ИмяРек=сред(ЗнПер,Найти(ЗнПер,".")+1);
		Иначе
			ИмяРек = "";
		КонецЕсли;
		
		Попытка
			Если Найти(строка(Объект1С),"Массив")>0 Тогда //это строка табличной части
				Объект1С = Контекст.СтрТабл[ИмяРек];
			Иначе
				Если ЗначениеЗаполнено(ИмяРек) Тогда
					Объект1С = Объект1С[ИмяРек];
				КонецЕсли;
				Если Найти(строка(Объект1С),"ТабличнаяЧасть")>0 Тогда //это сама табличная часть
					Если ИмяПеременнойВПараметре и Контекст.Ини[Параметр].Свойство("Отбор") Тогда
						Отбор = Новый Структура;
						Для Каждого Элемент Из Контекст.Ини[Параметр].Отбор Цикл
							Отбор.Вставить(Элемент.Ключ, РассчитатьЗначениеНаСервере(Элемент.Значение, Контекст));
						КонецЦикла;
						Если Лев(строка(Объект1С),10) = "Справочник" Тогда
							ТипМетаданных = "Справочники";
						Иначе
							ТипМетаданных = "Документы";
						КонецЕсли;
						ИмяОбъектаИТЧ = РазбитьСтрокуВМассив(строка(Объект1С), ".");
						Реквизиты = Метаданные[ТипМетаданных][ИмяОбъектаИТЧ[1]].ТабличныеЧасти[ИмяОбъектаИТЧ[2]].Реквизиты;
						СтрокиТЧ = Объект1С.НайтиСтроки(Отбор);
						Для Каждого СтрокаТЧ Из СтрокиТЧ Цикл 
							СтруктураСтрокиТЧ = Новый Структура();
							Для Каждого Реквизит Из Реквизиты Цикл 
								СтруктураСтрокиТЧ.Вставить(Реквизит.Имя, СтрокаТЧ[Реквизит.Имя]);
							КонецЦикла;
							Возврат СтруктураСтрокиТЧ;
						КонецЦикла;
						Возврат Неопределено;
					КонецЕсли;
				КонецЕсли;	
			КонецЕсли;
			Если ИмяПеременнойВПараметре и Контекст.Ини[Параметр].Свойство("Формат") Тогда // Надо установить отбор
				Объект1С = Формат(Объект1С,	Контекст.Ини[Параметр].Формат);
			КонецЕсли;
			
			Возврат Объект1С;
			
		Исключение
			ошибка = ОписаниеОшибки();
		КонецПопытки;	
	ИначеЕсли ПервыйСимвол="^" Тогда	// формула
		Возврат сбисВычислитьФормулуНаСервере(ЗнПер, Параметр, Контекст);
	ИначеЕсли ПервыйСимвол="'" Тогда	 // строка
		Если ЗнПер="'Истина'" Тогда
			Возврат Истина;
		ИначеЕсли ЗнПер="'Ложь'" Тогда
			Возврат Ложь;
		ИначеЕсли ИмяПеременнойВПараметре и ПараметрИни.Свойство("Тип") и ПараметрИни.Тип = "Число" Тогда
			возврат Число(Сред(ЗнПер,2,СтрДлина(ЗнПер)-2));
		ИначеЕсли ИмяПеременнойВПараметре и ПараметрИни.Свойство("Тип") и ПараметрИни.Тип = "Запрос" Тогда
			Запрос = Новый Запрос;
			Запрос.Текст=Сред(ЗнПер,2,СтрДлина(ЗнПер)-2);
			Если ПараметрИни.Свойство("Отбор") Тогда
				Для Каждого Элемент Из ПараметрИни.Отбор Цикл
					Запрос.УстановитьПараметр(Элемент.Ключ, РассчитатьЗначениеНаСервере(Элемент.Значение, Контекст));
				КонецЦикла;
			КонецЕсли;
			РезультатЗапроса = Запрос.Выполнить();
			Выборка = РезультатЗапроса.Выбрать();
			Если ПараметрИни.Свойство("Выбрать") и нрег(ПараметрИни.Выбрать) = "все" Тогда
				РезультатМассив = Новый Массив;
				Пока Выборка.Следующий() Цикл
					РезультатСтруктура = Новый Структура;
					Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
						РезультатСтруктура.Вставить(Колонка.Имя, Выборка[Колонка.Имя]);
					КонецЦикла;
					РезультатМассив.Добавить(РезультатСтруктура);
				КонецЦикла;
				Возврат РезультатМассив;
			Иначе
				Если Выборка.Количество()=0 Тогда
					Возврат Неопределено;
				КонецЕсли;
				РезультатСтруктура = Новый Структура;
				Выборка.Следующий();
				Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
					РезультатСтруктура.Вставить(Колонка.Имя, Выборка[Колонка.Имя]);
				КонецЦикла;
				Возврат РезультатСтруктура;
			КонецЕсли;
		Иначе
			возврат Сред(ЗнПер,2,СтрДлина(ЗнПер)-2);
		КонецЕсли;
	ИначеЕсли ПозТочки>0 Тогда
		ПервыйСимвол = Лев(ЗнПер, ПозТочки-1);
		
		Если ПервыйСимвол = "Справочник" Тогда	// ссылка на справочник
			ИмяРек=сред(ЗнПер,12);
			Если Контекст.Ини[Параметр].Свойство("Отбор") Тогда
				Отбор = Новый Структура;
				Владелец = Неопределено;
				Для Каждого Элемент Из Контекст.Ини[Параметр].Отбор Цикл
					Если Элемент.Ключ = "Владелец" Тогда
						Владелец = РассчитатьЗначениеНаСервере(Элемент.Значение, Контекст);
					Иначе
						Отбор.Вставить(Элемент.Ключ, РассчитатьЗначениеНаСервере(Элемент.Значение, Контекст));
					КонецЕсли;
				КонецЦикла;
				Если ЗначениеЗаполнено(Владелец) Тогда
					Выборка = Справочники[ИмяРек].Выбрать(,Владелец,Отбор);
				Иначе
					Выборка = Справочники[ИмяРек].Выбрать(,,Отбор);
				КонецЕсли;
				Если Выборка.Следующий() Тогда
					Возврат Выборка.Ссылка;
				Иначе
					Возврат Неопределено;
				КонецЕсли;
			Иначе
				возврат Справочники[ИмяРек];
			КонецЕсли;
		ИначеЕсли ПервыйСимвол = "Документ" Тогда // ссылка на документ	
			ИмяРек=сред(ЗнПер,10);
			возврат Контекст.Документ;
		ИначеЕсли ПервыйСимвол = "Константа" Тогда	// константа
			ИмяРек=сред(ЗнПер,11);
			возврат Константы[ИмяРек].Получить();
		ИначеЕсли ПервыйСимвол = "Перечисление" Тогда	// значение перечисления
			ИмяРек=сред(ЗнПер,14);
			возврат Перечисления[ИмяРек];
		ИначеЕсли ПервыйСимвол = "РегистрыСведений" Тогда	// ссылка на регистр сведений
			ИмяРек=сред(ЗнПер,18);
			Если Не Контекст.Ини[Параметр].Свойство("Отбор") Тогда
				Возврат Неопределено;
			КонецЕсли;
			Отбор = Новый Структура;
			Если Контекст.Ини[Параметр].Свойство("СрезПоследних") Тогда
				
				Для Каждого Элемент Из Контекст.Ини[Параметр].Отбор Цикл
					Отбор.Вставить(Элемент.Ключ, РассчитатьЗначениеНаСервере(Элемент.Значение, Контекст));
				КонецЦикла;
				ДатаСреза = РассчитатьЗначениеНаСервере(Контекст.Ини[Параметр].СрезПоследних, Контекст);
				НаборЗаписей = РегистрыСведений[ИмяРек].СрезПоследних(ДатаСреза,Отбор);
			Иначе
				НаборЗаписей = РегистрыСведений[ИмяРек].СоздатьНаборЗаписей();
				
				Для Каждого Элемент Из Контекст.Ини[Параметр].Отбор Цикл
					
					НаборЗаписей.Отбор[Элемент.Ключ].Установить(РассчитатьЗначениеНаСервере(Элемент.Значение, Контекст));
				КонецЦикла;
				НаборЗаписей.Прочитать();
			КонецЕсли;
			Если НаборЗаписей.Количество()=0 Тогда
				Возврат Неопределено;
			КонецЕсли;
			Запись = НаборЗаписей.Получить(0);
			Результат = Новый Структура();
			Ресурсы = Метаданные.РегистрыСведений[ИмяРек].Ресурсы;	
			Для Каждого Ресурс Из Ресурсы Цикл 
				Результат.Вставить(Ресурс.Имя, Запись[Ресурс.Имя]);
			КонецЦикла;
			возврат Результат;
		ИначеЕсли ПервыйСимвол = "ПланыСчетов" Тогда	// alo ПланыСчетов
			ИмяРек=сред(ЗнПер,13);
			Если Контекст.Ини[Параметр].Свойство("Отбор") Тогда
				Отбор = Новый Структура;
				Для Каждого Элемент Из Контекст.Ини[Параметр].Отбор Цикл
					Отбор.Вставить(Элемент.Ключ, РассчитатьЗначениеНаСервере(Элемент.Значение, Контекст));
				КонецЦикла;
				Выборка = ПланыСчетов[ИмяРек].Выбрать(,Отбор);
				Если Выборка.Следующий() Тогда
					Возврат Выборка.Ссылка;
				Иначе
					Возврат Неопределено;
				КонецЕсли;
			Иначе
				возврат ПланыСчетов[ИмяРек];
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Найти(ЗнПер,"'") = 0 и ПозТочки = 0 и ЗначениеЗаполнено(ЗнПер) и Контекст.Переменные.Свойство(ЗнПер) Тогда
		возврат Контекст.Переменные[ЗнПер];
	Иначе
		возврат Неопределено;
	КонецЕсли	
КонецФункции

&НаСервереБезКонтекста
Процедура СбисСкопироватьСтруктуру(СтруктураКуда, знач СтруктураОткуда)  Экспорт
	// Процедура копирует структуру	
	Для Каждого Элемент Из СтруктураОткуда Цикл	
		Если ТипЗнч(СтруктураОткуда) = Тип("Массив") Тогда
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Структура") Тогда
			//Если Не СтруктураКуда.Свойство(Элемент.Ключ) или СтруктураКуда[Элемент.Ключ] = Неопределено или ТипЗнч(СтруктураКуда[Элемент.Ключ])<>Тип("Структура") Тогда
			СтруктураКуда.Вставить(Элемент.Ключ, Новый Структура);
			//КонецЕсли;
			сбисСкопироватьСтруктуру(СтруктураКуда[Элемент.Ключ], Элемент.Значение);				
		ИначеЕсли Не СтруктураКуда.Свойство(Элемент.Ключ) Тогда
			СтруктураКуда.Вставить(Элемент.Ключ,Элемент.Значение);
		Иначе
			СтруктураКуда[Элемент.Ключ] = Элемент.Значение;			
		КонецЕсли;
	КонецЦикла;	
КонецПроцедуры

//Функция заполняет реквизиты объекта 1С из одноименных полей структуры. Поддерживаемые типы: Документ, Справочник	
&НаСервереБезКонтекста
Функция СоздатьОбъектИзСтруктуры(Знач СтруктураДокОбъект, Знач ДополнительныеПараметры, Отказ)
	ОбъектСсылка	= ДополнительныеПараметры.ОбъектПерезаполнитьСсылка;
	ОбъектПодТип	= ДополнительныеПараметры.ПодТипОбъекта;
	ОбъектТип		= ДополнительныеПараметры.ТипОбъекта;
	
	ЭтоНовый		= Не ЗначениеЗаполнено(ОбъектСсылка);
	Объект1СЗначение= Неопределено;
	
	Результат	= Новый Структура("Тип, Ссылка, Состояние, Сообщение");
	ТекстТип	= НРег(Лев(ОбъектТип, 1)) + Сред(ОбъектТип, 2);
	ТекстОшибки	= "";
	//Получаем объект для редактирования и записи
	Если ЭтоНовый Тогда
		Если ОбъектТип = "Справочник" Тогда
			Попытка	
				Объект1СЗначение = Справочники[ОбъектПодТип].СоздатьЭлемент();
			Исключение
				ТекстОшибки = ОписаниеОшибки();
				Отказ = Истина;
			КонецПопытки;
		Иначе
			Попытка	
				Объект1СЗначение = Документы[ОбъектПодТип].СоздатьДокумент();
			Исключение
				ТекстОшибки = ОписаниеОшибки();
				Отказ = Истина;
			КонецПопытки;
		КонецЕсли;
		Результат.Тип = ОбъектТип + "." + ОбъектПодТип;
	Иначе
		Попытка
			Результат.Тип	= ОбъектТип + "." + ОбъектСсылка.Метаданные().Имя;
			Объект1СЗначение= ОбъектСсылка.ПолучитьОбъект();
		Исключение
			Результат.Тип = ОбъектТип + "." + ОбъектПодТип;
			ТекстОшибки = ОписаниеОшибки();
			Отказ = Истина;
		КонецПопытки;
	КонецЕсли;
	Если Отказ Тогда
		Результат.Состояние = "Ошибка формирования " + ТекстТип + "а.";
		Если ЭтоНовый Тогда
			Результат.Сообщение = "Не удалось создать " + ?(ОбъектТип = "Документ", "новый " + ТекстТип,  "новую запись " + ТекстТип + "а") + ". " + ТекстОшибки;
		Иначе
			Результат.Сообщение = "Не удалось прочитать объект " + Строка(ОбъектСсылка) + ". " + ТекстОшибки;		
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	//Заполняем объект данными		
	Для Каждого Элемент Из СтруктураДокОбъект Цикл
		Если ТипЗнч(Элемент.Значение) = Тип("Массив") Тогда
			Объект1СЗначение[Элемент.Ключ].Очистить();
			Для Каждого Строка Из Элемент.Значение Цикл
				НоваяСтрока = Объект1СЗначение[Элемент.Ключ].Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
			КонецЦикла;
		Иначе
			Объект1СЗначение[Элемент.Ключ] = Элемент.Значение;
		КонецЕсли;
	КонецЦикла;
	//Записываем изменения
	Попытка
		Объект1СЗначение.Записать();
		ОбъектСсылка = Объект1СЗначение.Ссылка;
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Отказ = Истина;
	КонецПопытки;
	//Пробуем заполним документу дату и повторно записать при ошибке.
	Если	Отказ
		И	ОбъектТип = "Документ" Тогда
		Отказ = Ложь;
		Попытка
			Объект1СЗначение.Дата = ТекущаяДата();
			Объект1СЗначение.Записать();
			ОбъектСсылка = Объект1СЗначение.Ссылка;
		Исключение
			ТекстОшибки = ОписаниеОшибки();
			Отказ = Истина;
		КонецПопытки;
	КонецЕсли;
	//Заполняем результат
	Если Отказ Тогда
		Результат.Состояние = "Ошибка формирования " + ТекстТип + "а.";
		Результат.Сообщение = "Не удалось записать " + ТекстТип + ". " + ТекстОшибки;
	Иначе
		СостояниеОбъекта	= ?(ЭтоНовый, "Создан", "Перезаполнен"); 
		Результат.Состояние = СостояниеОбъекта + ".";
		Результат.Сообщение = СостояниеОбъекта + " " + ТекстТип + " " + Строка(ОбъектСсылка);
		Результат.Ссылка	= ОбъектСсылка;		
	КонецЕсли;
	Возврат Результат;
КонецФункции

//Возвращает Истина, если есть ВычислитьНаСервере, либо Вычислить определенного вида
//В СтрокуПараметраВычислить Отдаётся значение параметра.
&НаСервереБезКонтекста
Функция ЕстьПараметрВычислитьНаСервере(Знач СбисЭлементПроверки, СтрокаПараметраВычислить=Неопределено)
	Возврат 	(	СбисЭлементПроверки.Свойство("ВычислитьНаСервере", СтрокаПараметраВычислить)//ВычислитьНаСервере берём в приоритете (совместимость старой логики). Только если нет узла, смотрим Вычислить
				И	ЗначениеЗаполнено(СтрокаПараметраВычислить))
			Или	(	СбисЭлементПроверки.Свойство("Вычислить", СтрокаПараметраВычислить) 
				И	ЗначениеЗаполнено(СтрокаПараметраВычислить)
				И	Не (	Лев(СтрокаПараметраВычислить,1) = "'"
						Или	Лев(СтрокаПараметраВычислить,1) = "{" 
						Или	Лев(СтрокаПараметраВычислить,1) = "^"));	
КонецФункции
					
////////////////////////////////////////////////////
//////Обработка составных узлов документа///////////
////////////////////////////////////////////////////
					
//Обрабатываем сложный узел. Возвращает структуру ини, с посчитанными значениями
//Пример сложного узла:
//<мНомСредИдентТов Имя="НомСредИдентТов">//Имя узла и атрибут имя не совпадают.
//	//Имя узла первой строки совпадает с атрибутом Имя и имеет Тип "ТабличнаяЧасть".
//	<НомСредИдентТов Данные="НомСредИдентТов" Тип="ТабличнаяЧасть">[Документ].ШтрихкодыУпаковок</НомСредИдентТов>
//	...
//</мНомСредИдентТов>
//Принцип обработки аналогчен общему: считаем клиентскую часть, формируем Расчитанное значение, на сервере досчитываем что не досчиталось
//Узел - Структура, обрабатываемый узел ини.
//Строка - строка таб части из вложения XML
//ДокОбъект - результирующий документ, который будет создан
//ДопПараметры - СтруктураФайла - вся структура вложения, МестныйКэш - структура кэша, Ини - контекст обрабатываемой строки из ини + узлы шапки
&НаКлиенте
Функция ОбработатьСложныйУзел_Клиент(Кэш, Узел, Строка, ДокОбъект, ДопПараметры)
	РезультатОбработкиСложногоУзла = Новый Структура;
	
	Для Каждого АтрибутУзла Из Узел Цикл
		Если Не ТипЗнч(АтрибутУзла.Значение) = Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;
		
		//Получить первый элемент внутри сложного узла и проверрить не массив ли он?
		Для Каждого Элемент Из АтрибутУзла.Значение Цикл	
			РассчитанноеЗначение = Неопределено;
			//Данные
			Если Элемент.Значение.Свойство("Данные") Тогда
				РассчитанноеЗначение = Кэш.ОбщиеФункции.РассчитатьЗначениеИзСтруктуры(Элемент.Значение.Данные, Строка);
			КонецЕсли;
			//Вычислить
			Если Элемент.Значение.Свойство("Вычислить") Тогда
				Контекст = Новый Структура("Ини, Документ, Переменные, СтруктураФайла, СтрТабл", ДопПараметры.Ини, АтрибутУзла.Значение, Новый Структура, ДопПараметры.СтруктураФайла, Строка);
				РассчитанноеЗначение = РассчитатьЗначение(Элемент.Значение.Вычислить,Контекст,Кэш);
			КонецЕсли;
			//Запись массива в табличную часть? Переходим к его обработке 
			Если	Элемент.Значение.Свойство("Тип")
				И	НРег(Элемент.Значение.Тип) = "табличнаячасть" Тогда
				//Формируем "РасчитанноеЗначение" в таб части. Заполнение док.Объекта уже на сервере
				РезультатОбработкиПодУзла = Новый Массив;
				Если ТипЗнч(РассчитанноеЗначение) = Тип("Массив") Тогда
					Для Каждого СоставнаяСтрока Из РассчитанноеЗначение Цикл
						Элемент.Значение.Вставить("РассчитанноеЗначение", СоставнаяСтрока);
						//РезультатОбработкиПодУзла.Добавить(ОбработатьЭлементСУ_Клиент(СоставнаяСтрока, АтрибутУзла.Значение, ДокОбъект[ИмяТЧ], ДокОбъект, ДопПараметры));
						РезультатОбработкиПодУзла.Добавить(ОбработатьЭлементСУ_Клиент(Кэш, СоставнаяСтрока, АтрибутУзла.Значение, ДокОбъект, ДопПараметры));
					КонецЦикла;
					РезультатОбработкиСложногоУзла.Вставить(АтрибутУзла.Ключ, Новый Структура("РассчитанноеЗначение", РезультатОбработкиПодУзла));
				ИначеЕсли Не РассчитанноеЗначение = Неопределено Тогда
					Элемент.Значение.Вставить("РассчитанноеЗначение", РассчитанноеЗначение);
					//РезультатОбработкиПодУзла.Добавить(ОбработатьЭлементСУ_Клиент(РассчитанноеЗначение, АтрибутУзла.Значение, ДокОбъект[ИмяТЧ], ДокОбъект, ДопПараметры));
					РезультатОбработкиПодУзла.Добавить(ОбработатьЭлементСУ_Клиент(Кэш, РассчитанноеЗначение, АтрибутУзла.Значение, ДокОбъект, ДопПараметры));
					РезультатОбработкиСложногоУзла.Вставить(АтрибутУзла.Ключ, Новый Структура("РассчитанноеЗначение", РезультатОбработкиПодУзла));
				КонецЕсли;
				//в обработке СУ интересует только поиск элемента СУ, сама обработка узлов идёт дальше
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;	
	Возврат РезультатОбработкиСложногоУзла;
КонецФункции

//Обрабатывает сложные узел на сервере, дозаполняет ДокОбъект
&НаСервереБезКонтекста
Процедура ОбработатьСложныйУзел_Сервер(Узел, Строка, ДокОбъект, ДопПараметры)
	Перем лПараметрВычислить, РассчитанноеЗначение, АтрибутУзлаЗначение;
	Для Каждого АтрибутУзла Из Узел Цикл
		Если		ТипЗнч(АтрибутУзла.Значение) = Тип("Структура")
			И	Не	АтрибутУзла.Ключ = "РассчитанноеЗначение" Тогда
			АтрибутУзлаЗначение = АтрибутУзла.Значение;
		Иначе
			Продолжить;
		КонецЕсли;
		//Если есть расчитанное значение, то оно было посчитано на клиенте. Берём его за основу и досчитываем.
		//Иначе пробуем посчитать на сервере
		Если АтрибутУзла.Значение.Свойство("РассчитанноеЗначение") Тогда
			АтрибутУзлаЗначение = АтрибутУзлаЗначение.РассчитанноеЗначение;
			Если ТипЗнч(АтрибутУзлаЗначение) = Тип("Массив") Тогда
				Для Каждого СтрокаАтрибутУзла Из АтрибутУзлаЗначение Цикл
					ОбработатьРасчитаннуюСтрокуЭлементаСУ_Сервер(СтрокаАтрибутУзла, Строка, ДокОбъект, ДопПараметры);
				КонецЦикла;
				Возврат;
			КонецЕсли;
		КонецЕсли;
		ОбработатьРасчитаннуюСтрокуЭлементаСУ_Сервер(АтрибутУзлаЗначение, Строка, ДокОбъект, ДопПараметры)
	КонецЦикла;	
КонецПроцедуры

//Функция возвращает результат обсчета сложного узла
&НаКлиенте
Функция ОбработатьЭлементСУ_Клиент(Кэш, Строка, СтруктураДанных, ДокОбъект, ДопПараметры)
	КонтекстИниСтроки = ДопПараметры.Ини;
	
	СтрокаИниРезультат = Новый Структура;
	Кэш.ОбщиеФункции.сбисСкопироватьСтруктуруНаКлиенте(КонтекстИниСтроки, СтруктураДанных);
	Кэш.ОбщиеФункции.сбисСкопироватьСтруктуруНаКлиенте(СтрокаИниРезультат, СтруктураДанных);

	//Ини - контекст строки основной ТЧ из узла Ини
	//СтрокаФайла = рассчитываемая строка данных из файла
	КонтекстРасчета = Новый Структура(
		"Ини,				ИниКонфигурация,		СтрокаФайла,СтрТабл,		Документ, СтруктураФайла, СоставПакета, Вложение, Переменные, ТекущееПолеКлюч, ТекущееПолеИни",
		КонтекстИниСтроки,	Кэш.Ини.Конфигурация,	Строка,		Новый Структура,ДокОбъект);
	ЗаполнитьЗначенияСвойств(КонтекстРасчета, ДопПараметры, "СтруктураФайла, СоставПакета, Вложение, Переменные");
	//Перебрать структуру данных и найти соответствие каждому элементу в структуре строки
	Для Каждого ЭлементСД Из СтруктураДанных Цикл
		КонтекстРасчета.ТекущееПолеКлюч = ЭлементСД.Ключ;
		КонтекстРасчета.ТекущееПолеИни = СтрокаИниРезультат[ЭлементСД.Ключ];
		СбисВычислитьПолеНаКлиенте(Кэш, КонтекстРасчета);
	КонецЦикла;
	Возврат СтрокаИниРезультат;
КонецФункции

&НаСервереБезКонтекста
Процедура ОбработатьРасчитаннуюСтрокуЭлементаСУ_Сервер(АтрибутУзлаЗначение, Строка, ДокОбъект, ДопПараметры)
	Перем лПараметрВычислить, РассчитанноеЗначение, ИмяТЧ;
	Для Каждого Элемент Из АтрибутУзлаЗначение Цикл
		Если		Элемент.Значение.Свойство("РассчитанноеЗначение", РассчитанноеЗначение)
			И	Не	РассчитанноеЗначение = Неопределено Тогда
			//Есть расчитанное значение
		ИначеЕсли 	ЕстьПараметрВычислитьНаСервере(Элемент.Значение, лПараметрВычислить) Тогда
			РассчитанноеЗначение = РассчитатьЗначениеНаСервере(лПараметрВычислить, Новый Структура("Ини, Документ, Переменные, СтруктураФайла, СтрокаФайла", ДопПараметры.Ини, АтрибутУзлаЗначение, ДопПараметры.Переменные, ДопПараметры.СтруктураФайла, Строка));					
		КонецЕсли;
							
		//Запись массива в табличную часть? Переходим к его обработке 
		Если	Элемент.Значение.Свойство("Тип")
			И	НРег(Элемент.Значение.Тип) = "табличнаячасть" Тогда
			//Какую ТЧ заполнять из массива?
			Если Найти(Элемент.Значение.Значение, "[") = 1 Тогда  // ссылка на реквизит
				ИмяТЧ = Сред(Элемент.Значение.Значение, Найти(Элемент.Значение.Значение,".") + 1);
			Иначе//Не правильно указан путь к ТЧ. Не обрабатываем.
				Возврат;				
			КонецЕсли;
			
			ДопПараметры.Вставить("ИмяТЧ", ИмяТЧ);
			Если НЕ ДокОбъект.Свойство(ИмяТЧ) Тогда
				ДокОбъект.Вставить(ИмяТЧ, Новый Массив);
			КонецЕсли;
			Если ТипЗнч(РассчитанноеЗначение) = Тип("Массив") Тогда
				Для Каждого Строка Из РассчитанноеЗначение Цикл
					ОбработатьЭлементСУ_Сервер(Строка, АтрибутУзлаЗначение, ДокОбъект[ИмяТЧ], ДокОбъект, ДопПараметры);
				КонецЦикла;
			ИначеЕсли Не РассчитанноеЗначение = Неопределено Тогда
				ОбработатьЭлементСУ_Сервер(РассчитанноеЗначение, АтрибутУзлаЗначение, ДокОбъект[ИмяТЧ], ДокОбъект, ДопПараметры);
			КонецЕсли;				
			//в обработке сложного узла интересует только поиск массива, сама обработка узлов структуры массива в специальной функции
			Прервать;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаСервереБезКонтекста
Процедура ОбработатьЭлементСУ_Сервер(Строка, СтруктураДанных, ТабЧастьСтруктура, ДокОбъект, ДопПараметры)
	Перем лПараметрВычислить;
	КонтекстИниСтроки = ДопПараметры.Ини;
	
	СтрокаРезультат = Новый Структура; //строка, которая будет добавлена в табличную часть
	СбисСкопироватьСтруктуру(КонтекстИниСтроки,	СтруктураДанных);

	КонтекстРасчета = Новый Структура(
	"Ини,				СтрокаФайла,СтрТабл,			ЗаполнитьРасчитанноеЗначение, СтруктураФайла, Переменные, ТекущееПолеКлюч",
	КонтекстИниСтроки,	Строка,		КонтекстИниСтроки,	Истина);
	ЗаполнитьЗначенияСвойств(КонтекстРасчета, ДопПараметры, "СтруктураФайла, Переменные");
	//Перебрать структуру данных и найти соответствие каждому элементу в структуре строки
	Для Каждого ЭлементСД Из СтруктураДанных Цикл
		КонтекстРасчета.ТекущееПолеКлюч = ЭлементСД.Ключ;
		СбисВычислитьПолеНаСервере(КонтекстИниСтроки[ЭлементСД.Ключ], КонтекстРасчета, СтрокаРезультат);
	КонецЦикла;
	
	Если ЗначениеЗаполнено(СтрокаРезультат) Тогда
		ТабЧастьСтруктура.Добавить(СтрокаРезультат);
	КонецЕсли;
КонецПроцедуры

//Проверяет узел на то, что он составной (таб.часть у вложения)
&НаКлиенте
Функция ЭтоСложныйУзел_Клиент(Кэш, Поле)
	Перем ЗначениеТипПодУзла;
	Если ТипЗнч(Поле) = Тип("Структура") Тогда
		//Если Поле.Свойство("НомСредИдентТов") Тогда
		//	Возврат Истина;
		//КонецЕсли;
		Для Каждого КлючИЗначение Из Поле Цикл
			Если	ТипЗнч(КлючИЗначение.Значение) = Тип("Структура")
				И	КлючИЗначение.Значение.Свойство(КлючИЗначение.Ключ, ЗначениеТипПодУзла)
				И	ЗначениеТипПодУзла.Свойство("Тип", ЗначениеТипПодУзла)
				И	НРег(ЗначениеТипПодУзла) = "табличнаячасть" Тогда
				Возврат Истина;
			КонецЕсли;
			//Проверку делаем по первому элементу узла. Если там нет описания, то адью.
			Прервать;
		КонецЦикла;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

//Проверяет узел на то, что он составной (таб.часть у вложения)
&НаСервереБезКонтекста
Функция ЭтоСложныйУзел_Сервер(Поле)
	Перем ЗначениеТипПодУзла;
	Если ТипЗнч(Поле) = Тип("Структура") Тогда
		//Если Поле.Свойство("НомСредИдентТов") Тогда
		//	Возврат Истина;
		//КонецЕсли;
		Для Каждого КлючИЗначение Из Поле Цикл
			Если	ТипЗнч(КлючИЗначение.Значение) = Тип("Структура")
				И	КлючИЗначение.Значение.Свойство(КлючИЗначение.Ключ, ЗначениеТипПодУзла)
				И	ЗначениеТипПодУзла.Свойство("Тип", ЗначениеТипПодУзла)
				И	НРег(ЗначениеТипПодУзла) = "табличнаячасть" Тогда
				Возврат Истина;
			КонецЕсли;
			Прервать;
		КонецЦикла;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

////////////////////////////////////////////////////
//////////Вспомогательные функции загрузки//////////
////////////////////////////////////////////////////
										
//Проводит поиск значения по узлу описания и обновление из описанного узла. Если не найдено, досоздаёт.
//Контекст - контекст расчета
//УППоиск - Ключ узла с описанием поиска.
//УПТип - Параметр, определяет тип объекта.
//УПОписаниеОбъекта - Ключ узла с описанием структуры для обновления объекта.
//Дополнительные параметры определяются в переменных из контекста узлами:
//	СбисНайтиИОбновить_Сообщить - сообщает о результате обновления(создания) объекта. По-умолчанию - Ложь (не сообщать)
//	СбисНайтиИОбновить_Обновлять - определяет необходимость обновить найденный объект. По-умолчанию - Ложь (вернуть ссылку, не трогая).
//	СбисНайтиИОбновить_Досоздать - определяет необходимость создать новый объект, если не найден. По-умолчанию - Истина (вернуть ссылку нового объекта).
&НаСервереБезКонтекста
Функция СбисНайтиИОбновить(Знач Контекст, Знач УППоиск, Знач УПТип="", Знач УПОписаниеОбъекта=Неопределено)
	Перем СообщитьСтатус, ОбновитьОбъект;
	РезультатПоиска = РассчитатьЗначениеНаСервере(УППоиск, Контекст);
	Если РезультатПоиска = Неопределено Тогда
		Если (	Контекст.Переменные.Свойство("СбисНайтиИОбновить_Досоздать", ОбновитьОбъект)
			И	ОбновитьОбъект = Ложь) Тогда
			Возврат РезультатПоиска;
		КонецЕсли;
	ИначеЕсли Не	(	Контекст.Переменные.Свойство("СбисНайтиИОбновить_Обновить", ОбновитьОбъект)
					И	ОбновитьОбъект = Истина) Тогда
		Возврат РезультатПоиска;
	КонецЕсли;
	
	УниверсальныйПоиск_Тип = СтрЗаменить(УПТип, ".", Символы.ПС);
	Отказ = Ложь;
	СтруктураДосоздать = РассчитатьЗначениеНаСервере(УПОписаниеОбъекта, Контекст);
	ПараметрыСоздания = Новый Структура("ТипОбъекта,ПодТипОбъекта,ОбъектПерезаполнитьСсылка", 
										СтрПолучитьСтроку(УниверсальныйПоиск_Тип, 1),
										СтрПолучитьСтроку(УниверсальныйПоиск_Тип, 2),
										РезультатПоиска);
	РезультатСоздания = СоздатьОбъектИзСтруктуры(СтруктураДосоздать, ПараметрыСоздания, Отказ);
	Если	Контекст.Переменные.Свойство("СбисНайтиИОбновить_Сообщить", СообщитьСтатус)
		И	СообщитьСтатус = Истина Тогда
		Сообщить(РезультатСоздания.Сообщение);
	КонецЕсли;
	Возврат РезультатСоздания.Ссылка;
КонецФункции
